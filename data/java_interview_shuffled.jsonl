{"system": "你是一名 Java 面试官。", "input": "C1 和 C2 的区别是什么？", "output": "C1 编译器偏向快速启动，编译优化较少；C2 注重峰值性能，优化更激进但编译成本更高。Server 模式一般使用 C2，Client 模式使用 C1，也可混合（Tiered Compilation）。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 Java Agent？", "output": "Java Agent 是一种字节码增强机制，可在类加载前或运行时修改字节码。常用于 APM 监控、Profiling、全链路追踪、AOP 增强等场景。"}
{"system": "你是一名架构面试官。", "input": "如何设计推荐系统？", "output": "典型流程包括：数据采集、特征工程、模型训练（CTR/CVR 模型）、多路召回、粗排/精排、推荐服务（召回融合与排序）、A/B 测试与反馈闭环。可结合实时流计算与离线批处理混合架构。"}
{"system": "你是一名 Java 面试官。", "input": "MyBatis 的二级缓存是什么？", "output": "二级缓存是基于 Mapper namespace 的跨 SqlSession 缓存，需要显式开启且实体可序列化。适用于读多写少场景，提高查询速度。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 @SpringBootApplication？", "output": "@SpringBootApplication 是 Spring Boot 的复合注解，包含 @Configuration、@EnableAutoConfiguration 和 @ComponentScan。用于标识启动类并启用自动装配。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 metaspace 扩容机制？", "output": "Metaspace 使用本地内存，按需向 OS 申请扩容，直到达到 MaxMetaspaceSize 限制。频繁扩容通常由类加载器泄漏或大量动态类导致。"}
{"system": "你是一名专业后端架构面试官。", "input": "分布式系统的核心挑战有哪些？", "output": "核心挑战包括：1）数据一致性（CAP、最终一致性）；2）网络不可靠（延迟、丢包、分区）；3）服务故障容错（重试、熔断、隔离）；4）负载均衡与扩展性；5）分布式事务；6）配置、调度与资源治理；7）全链路监控与可观测性；8）安全与权限控制。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是内存屏障？", "output": "内存屏障是 CPU 指令，用于限制指令重排序并保证内存可见性，包括 LoadLoad、LoadStore、StoreStore、StoreLoad。volatile 就是通过内存屏障实现可见性与有序性。"}
{"system": "你是一名并发专家。", "input": "什么是 LongAdder？", "output": "LongAdder 通过分散热点到多个 Cell 并在最终计算时合并结果，减少 CAS 冲突，在高并发计数场景下比 AtomicLong 吞吐更高。"}
{"system": "你是一名操作系统面试官。", "input": "什么是虚拟内存？", "output": "虚拟内存通过将不常用页面换出到磁盘，使系统拥有超过物理内存的可用空间。它借助页表完成虚拟地址到物理地址映射，提高内存利用率与隔离性。"}
{"system": "你是一名架构面试官。", "input": "如何设计高可用系统？", "output": "常见做法有多副本、负载均衡、自动故障转移、跨机房部署、缓存层、限流熔断、服务隔离、监控报警以及数据多活架构。目标是容错、快速恢复和持续对外提供服务。"}
{"system": "你是一名专业 Java 面试官。", "input": "标记-整理算法为什么适合老年代？", "output": "老年代对象存活率高，复制算法成本过高；标记-整理避免大量存活对象复制，同时整理内存减少碎片，提高大对象分配效率。"}
{"system": "你是一名 Java 面试官。", "input": "主从同步有哪些方式？", "output": "包括异步复制（性能好但可能丢数据）、半同步复制（主库等待至少一个从库确认）和增强半同步复制（提升可靠性）。"}
{"system": "你是一名 Java 面试官。", "input": "什么是锁消除？", "output": "锁消除是 JIT 通过逃逸分析识别对象没有跨线程访问，从而移除无意义的锁操作。能显著提升无竞争场景的性能。"}
{"system": "你是一名并发专家。", "input": "什么是饥饿？", "output": "饥饿是指线程长期得不到 CPU 时间片或无法获取锁，比如使用不公平锁或高优先级线程长期占用资源导致低优先级线程一直被饿死。"}
{"system": "你是一名 Java 面试官。", "input": "为什么建议尽量使用 StringBuilder？", "output": "StringBuilder 是可变的，并且无锁（非线程安全），在单线程场景中性能远高于 StringBuffer。适用于大量字符串拼接，避免频繁创建临时对象。"}
{"system": "你是一名 Java 面试官。", "input": "@Configuration 和 @Bean 的作用是什么？", "output": "@Configuration 标记配置类，并通过 CGLIB 代理保证方法返回的 Bean 为单例。@Bean 用于将方法返回对象注册为 Spring Bean，常用于第三方类或手动构造的 Bean。"}
{"system": "你是一名分布式面试官。", "input": "什么是服务熔断？", "output": "服务熔断是在下游异常（超时、失败率高）时临时切断调用链，返回快速失败，从而保护系统避免雪崩。常见实现包括 Hystrix、Sentinel 的熔断规则。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Boot 如何连接数据库？", "output": "通过 spring.datasource 配置数据库连接信息，Spring Boot 会自动装配 DataSource，默认使用 HikariCP 连接池。配合 JPA、MyBatis 等即可完成 ORM 映射与数据库访问。"}
{"system": "你是一名专业的网络通信面试官，请给出结构化、专业回答。", "input": "TCP 和 UDP 有什么区别？", "output": "TCP 与 UDP 的核心区别如下：\n1）连接性：TCP 面向连接（三次握手），UDP 无连接。\n2）可靠性：TCP 保证可靠传输、顺序到达；UDP 不保证可靠性与顺序。\n3）流控与拥塞控制：TCP 有滑动窗口与拥塞控制；UDP 无控制，传输更自由。\n4）性能：TCP 延迟高、开销大；UDP 延迟低、适合实时场景。\n5）典型场景：TCP 用于文件传输、HTTP；UDP 用于直播、语音、DNS 等实时业务。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 Java 反射？", "output": "反射允许在运行时动态获取类的信息并操作方法、字段和构造器。是 Spring IoC、ORM 等框架的核心机制之一，但性能较差且会破坏封装性。"}
{"system": "你是一名网络通信专家。", "input": "HTTP 状态码有哪些？", "output": "状态码分为：1xx（信息）、2xx（成功：200/204/206）、3xx（重定向：301/302/304）、4xx（客户端错误：400/401/403/404）、5xx（服务端错误：500/502/503/504）。"}
{"system": "你是一名 Java 面试官。", "input": "AOF 重写（Rewrite）的作用是什么？", "output": "AOF 重写通过合并旧命令生成更紧凑的日志文件，减少文件体积，避免 AOF 无限膨胀，同时加快 Redis 重启时的恢复速度。"}
{"system": "你是一名 Java 面试官。", "input": "Spring 中事务传播行为有哪些？", "output": "事务传播包括：REQUIRED、REQUIRES_NEW、NESTED、SUPPORTS、NOT_SUPPORTED、MANDATORY 和 NEVER。它们决定方法被调用时事务如何传递或新建。"}
{"system": "你是一名 OS 面试官。", "input": "线程安全与进程安全区别？", "output": "线程共享同一进程资源，因此更容易出现资源竞争和线程安全问题。进程有独立的地址空间，相互隔离，天然更安全。"}
{"system": "你是一名操作系统面试官。", "input": "线程是什么？", "output": "线程是 CPU 调度与执行的最小单位，属于轻量级进程，同一进程内线程共享内存与资源。适用于并发和多任务执行。"}
{"system": "你是一名架构面试官。", "input": "服务熔断与降级的区别是什么？", "output": "熔断是系统检测到错误率或延迟过高时自动切断调用链，避免扩散；降级是业务主动提供备选方案或静态结果。熔断偏技术保护，降级偏业务策略。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Boot 中如何做全局异常处理？", "output": "使用 @ControllerAdvice + @ExceptionHandler 定义全局异常捕获器，统一处理业务异常、系统异常，并返回标准化的响应结构。"}
{"system": "你是一名专业 Java 面试官。", "input": "Java 对象的可见性是如何保证的？", "output": "通过 volatile 禁止重排序、synchronized 和锁的释放→获取规则、final 的安全发布语义，以及 JMM 的 happens-before 关系共同保证可见性。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 Spring Cloud？", "output": "Spring Cloud 是一套微服务治理框架，提供注册发现、配置中心、网关、负载均衡、熔断限流等基础设施。它让微服务开发更加标准化、组件化。和 Spring Boot 配合使用效果最好。"}
{"system": "你是一名 Java 面试官。", "input": "Gateway 中的过滤器有哪些类型？", "output": "Gateway 过滤器包括：1）GatewayFilter：应用于某个路由规则；2）GlobalFilter：全局过滤器；3）Pre Filter：请求进入前处理；4）Post Filter：响应返回后处理。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 Kafka 分区？", "output": "分区是 Topic 的物理分片，提升吞吐并支持并行消费。每个分区内部消息严格有序，是 Kafka 水平扩展的基础。"}
{"system": "你是一名并发专家。", "input": "什么是生产者消费者模型？", "output": "生产者消费者模型通过共享阻塞队列让生产与消费解耦，提高并发吞吐。生产者写入队列，消费者从队列取任务，实现并行处理与流量削峰。"}
{"system": "你是一名并发面试官。", "input": "Exchanger 是做什么的？", "output": "Exchanger 是线程之间的数据交换器，允许两个线程在同步点交换对象。适用于生产者-消费者配对或遗传算法等双线程协作任务。"}
{"system": "你是一名 Java 面试官。", "input": "元空间 OOM 的原因是什么？", "output": "元空间存放类元数据，OOM 多因大量动态生成类，如 CGLIB 动态代理、字节码增强工具频繁创建类，或元空间配置过小导致内存不足。"}
{"system": "你是一名专业的分布式系统面试官，请给出结构化、专业回答。", "input": "什么是分布式系统？", "output": "分布式系统由多节点通过网络协同完成单一业务目标。核心特性包括：可扩展性、高可用性、容错能力、性能提升和成本优化。典型实现有微服务架构、分布式数据库、缓存集群、消息队列等。"}
{"system": "你是一名 Java 面试官。", "input": "@Component、@Service、@Repository、@Controller 有什么区别？", "output": "@Component 是通用组件注解；@Service 表示业务层；@Repository 标识数据访问层并提供异常转换；@Controller 用于 Web 层控制器。"}
{"system": "你是一名 Java 面试官。", "input": "什么是染色指针？", "output": "ZGC 使用指针高位比特保存对象标记状态（如是否被标记、是否重定位），使得标记与移动可以并发进行，从而实现极低停顿的 GC。"}
{"system": "你是一名 Java 面试官。", "input": "什么是熔断器的状态？", "output": "熔断器有三种状态：Closed（正常放行）、Open（拒绝请求）、Half-Open（试探恢复）。它用于隔离下游故障，避免级联雪崩。状态会根据请求成功率自动切换。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 CAS？", "output": "CAS（Compare And Swap）比较并交换，用于实现无锁原子操作。优点是避免阻塞，缺点包括 ABA 问题、自旋耗时、难以处理多个变量的原子性。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 为什么不适合做强一致性？", "output": "Redis 主从是异步复制，存在复制延迟导致读到旧数据的可能。即使开启半同步，也无法完全避免节点故障时的数据丢失。因此更适合最终一致性场景。"}
{"system": "你是一名 Java 面试官。", "input": "Eureka 的自我保护机制是什么？", "output": "自我保护机制在短时间内心跳骤降时，不立即将实例剔除，防止因网络抖动导致误下线。Eureka 会继续保留注册信息，提高系统可用性和容错性。"}
{"system": "你是一名 Java 面试官。", "input": "什么是类型擦除？", "output": "Java 泛型在编译期校验类型，运行时会被擦除为原始类型（Object 或上界）。带来限制如不能 new T、不能使用基本类型泛型、方法签名擦除后可能产生重载冲突。"}
{"system": "你是一名并发专家。", "input": "为什么不建议 Executors 创建线程池？", "output": "Executors 提供的线程池要么使用无界队列（如 newFixedThreadPool），要么最大线程数无限制（如 newCachedThreadPool），容易在高并发场景导致 OOM。推荐手动使用 ThreadPoolExecutor 明确设置核心线程、最大线程、队列大小及拒绝策略。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是指针碰撞？", "output": "指针碰撞是一种快速的对象分配方式，当堆是连续内存时，只需移动分配指针即可完成对象分配。高效但依赖于堆无碎片，通常配合复制算法使用。"}
{"system": "你是一名 Java 面试官。", "input": "如何避免元空间 OOM？", "output": "可通过增大 MaxMetaspaceSize、减少动态类生成、避免频繁使用 CGLIB 动态代理、排查类加载器泄漏来避免元空间 OOM。核心是减少不可回收的 Class 对象数量。"}
{"system": "你是一名 Java 面试官。", "input": "如何排查堆 OOM？", "output": "开启 heap dump（-XX:+HeapDumpOnOutOfMemoryError），通过 MAT/VisualVM 分析泄漏路径。重点排查大对象、缓存未清理、线程池未关闭、静态集合持有引用等问题。"}
{"system": "你是一名架构师。", "input": "如何防止超卖？", "output": "防止超卖常用方案有：Redis 原子扣减、Lua 脚本、分布式锁、库存预减、消息队列削峰，以及数据库层面的唯一约束或行锁。核心是保证库存操作的原子性与串行化。"}
{"system": "你是一名专业面试官。", "input": "TCP 四次挥手流程是什么？", "output": "流程是：客户端发送 FIN；服务端回复 ACK；服务端再发 FIN；客户端最终 ACK。因为 TCP 的关闭是双向的，所以需要两对 FIN-ACK 确认各自方向的数据通道关闭。"}
{"system": "你是一名网络面试官。", "input": "CLOSE_WAIT 大量堆积意味着什么？", "output": "表示对端已关闭连接，本端未调用 close() 释放 socket。通常是应用未正确处理连接关闭，导致资源泄漏。"}
{"system": "你是一名网络专家。", "input": "什么是多路复用 IO？", "output": "多路复用通过 select/poll/epoll 让单线程同时监听多个 FD 的事件。它避免了为每个连接创建线程，大幅提升 IO 并发处理能力。"}
{"system": "你是一名分布式系统面试官。", "input": "如何处理消息积压？", "output": "处理方式包括：增加消费者实例、提升消费者处理能力、对热点分区拆分、临时扩容消费集群、对低优先级消息降级或丢弃。核心是提升消费速度并削峰。"}
{"system": "你是一名 OS 专家。", "input": "什么是 epoll？", "output": "epoll 是 Linux 的高性能 IO 多路复用机制，采用事件回调模型，时间复杂度 O(1)。适合处理大量并发连接，比 select/poll 更高效。"}
{"system": "你是一名 Java 面试官。", "input": "MySQL 为什么要使用 B+Tree？", "output": "B+Tree 层级浅、磁盘访问次数少，叶子节点顺序链表天然支持范围查询，非常适合磁盘存储结构。其良好的局部性和稳定的查找时间使其成为数据库索引的最佳选择。"}
{"system": "你是一名并发专家。", "input": "什么是重量级锁？", "output": "重量级锁是锁竞争激烈时升级后的锁，依赖操作系统的互斥量实现。线程会挂起和唤醒，导致上下文切换成本高，适合竞争极强的场景。"}
{"system": "你是一名Java面试官。", "input": "CMS GC 的优缺点是什么？", "output": "CMS 优点是低停顿、并发标记清除，适合对延迟敏感的应用。缺点是有浮动垃圾、会产生内存碎片，并可能因并发模式失败触发 Full GC。"}
{"system": "你是一名 Java 面试官。", "input": "什么是线程池？", "output": "线程池通过复用线程降低频繁创建/销毁的开销，提高并发性能。它基于 Executor 框架，提供任务提交、排队、调度和拒绝策略等能力，是服务端高并发的基础组件。"}
{"system": "你是一名专业的Java面试官，请给出结构化、专业回答。", "input": "什么是 Spring？为什么要使用 Spring 框架？", "output": "Spring 是一个轻量级企业级 Java 开发框架，核心提供 IoC 容器和 AOP 能力，并扩展出 MVC、数据访问、事务管理等模块。使用 Spring 的主要原因包括：解耦与模块化设计；统一的编程模型；丰富生态与第三方集成；提高测试性与维护性；适用于从单体到微服务的各种架构。"}
{"system": "你是一名 Java 面试官。", "input": "什么是双亲委派模型？", "output": "双亲委派模型要求类加载请求先交给父加载器处理，父加载器找不到时才由子加载器加载。这样可避免类冲突，并确保核心类库（如 java.lang.*）不能被篡改。"}
{"system": "你是一名专业 Java 面试官。", "input": "对象被判为不可达后会立即回收吗？", "output": "不会。JVM 会进行两次标记：第一次标记为不可达对象，第二次判断是否需要执行 finalize（若被重写）。仅 finalize 未复活对象才会被真正回收。"}
{"system": "你是一名操作系统面试官。", "input": "什么是信号量？", "output": "信号量是一种用于进程/线程同步的计数器。分为计数信号量（控制并发量）和二元信号量（实现互斥）。依赖 P/V 操作实现访问控制。"}
{"system": "你是一名专业架构师。", "input": "ZooKeeper 分布式锁原理是什么？", "output": "ZK 通过创建临时顺序节点实现锁竞争，节点序号最小者获得锁。失败的客户端监听前驱节点删除事件，避免轮询，既公平又避免死锁，具备天然的高可用特性。"}
{"system": "你是一名专业 Java 面试官。", "input": "为什么需要分代？", "output": "因为大量对象生命周期极短，分代让新生代使用复制算法（成本低、速度快），老年代使用标记-整理，提高整体 GC 性能。遵循“弱分代假说”和“强分代假说”设计。"}
{"system": "你是一名专业 Java 面试官。", "input": "JVM 的对象创建过程是什么？", "output": "对象创建流程包括：1）检查类是否已加载；2）在堆中分配空间（指针碰撞或空闲列表）；3）将对象内存初始化为零值；4）设置对象头（哈希、锁等结构）；5）执行构造器完成初始化。"}
{"system": "你是一名专业 Java 面试官。", "input": "对象在堆中的分配策略是什么？", "output": "普通对象优先在 Eden 区分配，大对象可能直接进入老年代；存活多次（晋升年龄达到阈值）的对象会晋升到老年代；在 Minor GC 前会做空间分配担保以确认老年代是否容纳晋升对象。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Cloud Eureka 的作用是什么？", "output": "Eureka 是服务注册中心，提供服务注册、服务发现及心跳检查。支持自我保护机制，避免网络抖动导致大规模实例下线。是 Spring Cloud 微服务治理的核心组件之一。"}
{"system": "你是一名 Java 面试官。", "input": "什么是嵌套类？", "output": "嵌套类是定义在另一个类内部的类，用于更好地组织代码结构。包括静态内部类和非静态内部类两种。常用于封装细粒度逻辑或构建者模式等场景。"}
{"system": "你是一名专业 Java 面试官。", "input": "Java 为什么不支持多继承？", "output": "主要是避免菱形继承带来的方法冲突和语义混乱，使类模型更简洁。Java 用接口提供多继承能力，同时保持实现层次清晰。"}
{"system": "你是一名 Java 面试官。", "input": "什么是事务 ACID？Spring 如何实现事务？", "output": "ACID 包括原子性、一致性、隔离性、持久性。Spring 通过 AOP 拦截 @Transactional 方法，使用 PlatformTransactionManager 管理连接、提交与回滚；底层利用数据库事务能力保证 ACID。"}
{"system": "你是一名 Java 面试官。", "input": "HotSpot 为什么叫 HotSpot？", "output": "因为 JVM 会探测“热点代码”，对频繁执行的代码进行 JIT 编译和优化，从而提升整体运行性能，因此得名 HotSpot。"}
{"system": "你是一名系统设计专家。", "input": "Service Mesh 的优点是什么？", "output": "Service Mesh 将流量治理从业务代码中剥离出来，提供统一的流量管理、熔断限流、灰度发布、可观测性和零信任安全（mTLS）。应用无需修改代码即可获得治理能力，使架构更清晰、演进更平滑。"}
{"system": "你是一名并发专家。", "input": "公平锁与非公平锁区别？", "output": "公平锁严格按等待队列顺序获取锁；非公平锁允许插队，减少线程切换、吞吐量更高但不公平。ReentrantLock 默认非公平锁。"}
{"system": "你是一名 Java 面试官。", "input": "什么是内联？", "output": "内联是 JIT 的重要优化之一，将被调用方法的代码直接展开到调用点，避免方法调用和栈帧创建开销。能显著提升小方法、高频方法的执行性能。"}
{"system": "你是一名系统设计专家。", "input": "如何设计接口幂等性？", "output": "常见方式：唯一请求 ID、防重表、乐观锁（版本号）、分布式锁、状态机校验。核心保证同一请求只执行一次，避免重复扣费等问题。"}
{"system": "你是一名并发专家。", "input": "为什么 ConcurrentHashMap 放弃了分段锁？", "output": "JDK8 中通过 CAS + synchronized 实现更细粒度的并发控制，避免 Segment 带来的锁竞争。链表转红黑树减少冲突，提高查询与写入性能，并简化结构。"}
{"system": "你是一名 Java 面试官。", "input": "HashMap 的工作原理？", "output": "HashMap 通过 hash(key) 定位桶位，冲突用链表解决；当链表长度 ≥8 且容量≥64 会转成红黑树提升查询效率。扩容时按负载因子重新分布节点。"}
{"system": "你是一名并发专家。", "input": "什么是 CopyOnWrite 容器？", "output": "CopyOnWrite 容器在写操作时复制底层数组，如 CopyOnWriteArrayList。读写分离，读无锁，适合读多写少场景，但写成本高且占用更多内存。"}
{"system": "你是一名 OS 面试官。", "input": "TLB 是什么？", "output": "TLB（Translation Lookaside Buffer）是页表的高速缓存，用于加速虚拟地址到物理地址的转换。命中 TLB 可避免多级页表查找，大幅降低内存访问延迟。"}
{"system": "你是一名 Java 面试官。", "input": "如何创建不可变类？", "output": "关键是禁止状态变化：所有字段设为 final 且私有；不提供 setter；构造函数完成全部初始化；返回内部对象的副本而不是直接暴露引用。"}
{"system": "你是一名专业的Java后端面试官，请给出结构化、专业回答。", "input": "Redis 为什么这么快？", "output": "Redis 高性能主要由于：\n1）完全基于内存操作，访问延迟低；\n2）使用高效数据结构（SDS、HashTable、SkipList 等）；\n3）单线程模型避免锁竞争；\n4）使用 epoll 等多路复用机制处理大量连接；\n5）协议简单、序列化开销低；\n6）优化的事件循环与 I/O 处理机制。"}
{"system": "你是一名操作系统专家。", "input": "缺页中断是什么？", "output": "缺页中断是在访问不在物理内存中的页时触发，由操作系统将该页从磁盘加载到内存，再恢复进程执行。是虚拟内存管理的核心机制。"}
{"system": "你是一名 Java 面试官。", "input": "Hystrix 是什么？", "output": "Hystrix 是 Netflix 开源的熔断与隔离框架，通过线程池隔离、超时、熔断和 fallback 来防止服务雪崩。虽然被进入维护模式，但理念被广泛继承。"}
{"system": "你是一名架构师。", "input": "如何设计高可用 API 网关？", "output": "核心思路是多副本部署并用负载均衡做流量分发，保持网关节点无状态化。再加上健康检查、熔断限流、路由降级等机制提升稳定性。同时要接入认证、监控、灰度能力，确保全链路可观测可控。"}
{"system": "你是一名 Java 面试官。", "input": "什么是位运算？", "output": "位运算包括 &、|、^、~、<<、>>、>>>，直接操作二进制位，性能极高。常用于 HashMap 扩容、权限控制与高性能计算等场景。"}
{"system": "你是一名系统架构面试官。", "input": "常见限流工具有哪些？", "output": "常见工具包括 Sentinel、Guava RateLimiter、Nginx 限流模块、Envoy、Istio Pilot 策略。可按业务选择本地限流或分布式限流方案。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是空闲列表？", "output": "空闲列表是堆在非连续内存情况下管理可用空间的数据结构，用链表维护多个空闲块。分配时通过首次适配或最佳适配等策略找到合适空间，用于减少内存碎片。"}
{"system": "你是一名并发专家。", "input": "Java 中实现定时任务的方式有哪些？", "output": "常见方式有：Timer（单线程，异常会终止）、ScheduledExecutorService（基于线程池，推荐）、Spring @Scheduled（业务友好）、Quartz（分布式调度）。大部分场景用 ScheduledThreadPool 就足够稳定且可扩展。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka 的副本机制是什么？", "output": "每个分区包含多个副本：一个 Leader 负责读写，Follower 异步同步 Leader 日志。ISR 副本组保证高可用，Leader 故障时可从 ISR 中选举新 Leader。"}
{"system": "你是一名 Java 面试官。", "input": "@Autowired 与 @Resource 的区别？", "output": "@Autowired 默认按类型注入，可结合 @Qualifier 指定名称；@Resource 默认按名称注入，遵循 JSR-250 标准。如果同名 Bean 存在优先选择 @Resource。"}
{"system": "你是一名 Java 面试官。", "input": "G1 为什么比 CMS 更好？", "output": "G1 引入分区化管理与 region 结构，能实现可预测的停顿时间，并且具备并发压缩能力，不会产生碎片。相比 CMS 更稳定、可控，适合大堆场景。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 @Conditional？", "output": "@Conditional 用于按条件加载 Bean，是自动装配的核心机制之一。常见扩展如 @ConditionalOnClass、@ConditionalOnMissingBean，用来控制 Bean 是否注入。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 OOM？", "output": "OOM（OutOfMemoryError）表示 JVM 无法为对象分配内存，常见包括堆 OOM、元空间 OOM、直接内存 OOM、GC overhead limit exceeded 等。"}
{"system": "你是一名网络通信面试官。", "input": "如何解决 TCP 粘包/拆包？", "output": "常见方式包括：固定长度消息、使用分隔符、在消息头添加长度字段、应用层自定义协议解析。Netty 通常使用 LengthFieldBasedFrameDecoder 解决。"}
{"system": "you are a Java 面试官。", "input": "HashMap 为什么线程不安全？", "output": "多线程扩容可能出现链表丢失、数据覆盖甚至死循环（JDK7）。并发写会导致数据不一致。线程安全替代品是 ConcurrentHashMap。"}
{"system": "你是一名 Java 面试官。", "input": "为什么不建议用 Executors 创建线程池？", "output": "Executors 默认使用无界队列或无限数量的线程，容易导致 OOM 或线程暴涨。更推荐手动使用 ThreadPoolExecutor，明确设置核心参数，确保行为可控。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 Spring Boot？", "output": "Spring Boot 是基于 Spring 的快速开发框架，提供自动装配、约定优于配置、Starter 依赖管理、嵌入式服务器等特性，大幅简化项目构建与部署流程。"}
{"system": "你是一名 Java 面试官。", "input": "什么是内部类？", "output": "内部类是定义在另一个类内部的类，包括成员内部类、静态内部类、局部内部类和匿名内部类。用于更好地组织代码与访问外部类的私有属性。"}
{"system": "你是一名并发专家。", "input": "什么是内存可见性问题？", "output": "内存可见性是指一个线程对共享变量的更新无法立即被其他线程看到，原因是 CPU 缓存和指令重排。通过 volatile、synchronized 或 Lock 能建立内存屏障，保证写入对其他线程立即可见。"}
{"system": "你是一名架构专家。", "input": "如何设计高并发抢购系统？", "output": "核心策略包括前端限流与验证码、Redis 原子扣库存、异步化下单（MQ 削峰）、数据库异步落库、防重 token、热点商品隔离、限流与熔断保护。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka 如何保证最多一次消费？", "output": "最多一次就是可能丢但不会重复。做法是先提交 offset 再消费消息，一旦消费失败 offset 也不会回滚。适合对数据一致性要求不高的场景。"}
{"system": "你是一名并发专家。", "input": "volatile 能解决指令重排吗？", "output": "能。volatile 在读写时会插入内存屏障，保证写后读的顺序不被 JVM 或 CPU 重排。它确保可见性和一定的有序性，但不保证原子性。"}
{"system": "你是一名 Java 面试官。", "input": "微服务之间的调用方式有哪些？", "output": "主要包括同步调用（Feign、RestTemplate、gRPC）和异步调用（MQ）。同步简单但耦合高；异步能削峰填谷、提高系统解耦能力。"}
{"system": "你是一名 Java 面试官。", "input": "MyBatis 如何分页？", "output": "MyBatis 可以用 RowBounds（逻辑分页）、在 SQL 中写 limit、或使用 PageHelper 等插件实现物理分页。生产环境一般使用插件或直接写 limit。物理分页性能更好。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 的 Lua 脚本有什么优势？", "output": "Lua 能将多条 Redis 命令作为一个原子操作执行，避免并发竞争问题；并且执行过程中不会被其他命令打断。它适合实现分布式锁、计数器、限流等需要原子性的复杂逻辑。"}
{"system": "你是一名 Java 面试官。", "input": "为什么 Redis 事务不支持回滚？", "output": "Redis 事务基于队列批量执行，遵循简单可预测原则，不提供复杂的回滚逻辑。执行阶段出现错误也不会中断剩余命令，以保持高性能与系统的稳定性。"}
{"system": "你是一名网络专家。", "input": "Netty 是如何实现零拷贝的？", "output": "Netty 通过 DirectBuffer（直接内存）、CompositeByteBuf（逻辑拼接无需拷贝）、FileRegion（文件传输）、以及底层的 sendfile 实现零拷贝。核心是减少用户态和内核态之间的数据复制，降低 CPU 开销。"}
{"system": "你是一名并发专家。", "input": "Semaphore 的作用是什么？", "output": "Semaphore 是一种信号量，用来限制并发访问的数量，比如限流、连接池、资源访问控制。它基于 AQS 的共享模式实现，可支持公平与非公平策略。"}
{"system": "你是一名 Java 面试官。", "input": "线程的生命周期是什么？", "output": "线程生命周期包括：新建 → 就绪 → 运行 → 阻塞/等待 → 终止。状态在 JVM 调度和锁竞争中不断转换。"}
{"system": "你是一名网络专家。", "input": "DNS 的作用是什么？", "output": "DNS 用于将域名解析为 IP 地址，支持递归查询和分级查询，并具有缓存机制降低延迟。还可实现简单的负载均衡，通过返回不同的 A 记录分散流量。"}
{"system": "你是一名 Java 面试官。", "input": "Spring MVC 的执行流程是什么？", "output": "请求先到 DispatcherServlet，然后通过 HandlerMapping 找到对应的 Controller 方法。接着 HandlerAdapter 调用方法并返回 ModelAndView，再由 ViewResolver 渲染视图。最终 DispatcherServlet 把结果返回给客户端。"}
{"system": "你是一名 JUC 专家。", "input": "BlockingQueue 有哪些实现？", "output": "常见实现包括：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue、DelayQueue。适用于不同的队列特性和并发需求。"}
{"system": "你是一名专业 Java 面试官。", "input": "为什么 GC 会出现 Stop-The-World？", "output": "GC 需要暂停所有用户线程来保证对象图的稳定性，以便进行标记与整理。即使是并发 GC，也无法完全避免多次短暂的 STW。"}
{"system": "你是一名专业 Java 面试官。", "input": "Java 虚拟机栈存储什么？", "output": "Java 栈为每次方法调用创建栈帧，栈帧包含局部变量表、操作数栈、动态链接和返回地址等。方法执行就是对栈帧的入栈、出栈过程。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 Kafka？", "output": "Kafka 是高吞吐、分布式的消息队列与流处理平台，基于分区日志、顺序写盘、零拷贝技术实现高性能。常用于日志采集、消息解耦、实时处理与事件流系统。"}
{"system": "你是一名并发专家。", "input": "什么是 AQS？", "output": "AQS 是构建同步器（如 ReentrantLock、CountDownLatch）的基础框架，通过一个 state 字段和 CLH 双向队列管理线程争用。核心是 CAS + 自旋 + 队列挂起的协作方式，提高锁实现的通用性与性能。"}
{"system": "你是一名专业的Java面试官。", "input": "final 关键字有哪些作用？", "output": "final 修饰变量使其不可修改，修饰方法防止被重写，修饰类禁止继承。它还能帮助编译器做优化，并让对象更加安全稳定。"}
{"system": "你是一名专业 Java 面试官。", "input": "JMM（Java Memory Model）解决了什么问题？", "output": "JMM 定义了线程间共享变量的可见性、有序性和原子性规则，并规范了 volatile、锁、final 等语义。它屏蔽了硬件缓存与编译器重排带来的并发不一致问题，让多线程行为可预期。"}
{"system": "你是一名专业 Java 面试官。", "input": "讲讲 Java 中的引用类型有哪些？", "output": "Java 有四种引用：强引用（不会被 GC 回收）、软引用（内存不足回收）、弱引用（下次 GC 必回收）、虚引用（仅用于接收回收回调）。主要用于缓存、资源管理和对象生命周期监控。"}
{"system": "你是一名 Java 面试官。", "input": "类加载失败的原因有哪些？", "output": "常见原因包括：类找不到（ClassNotFound）、签名校验失败、安全管理器限制、父加载器已加载同名类、类版本过高（UnsupportedClassVersionError）。"}
{"system": "你是一名专业 Java 面试官。", "input": "堆内存的作用是什么？", "output": "堆是 JVM 最大的内存区域，用于存放对象实例和数组，是 GC 主要管理的地方。新生代、老年代等区域都位于堆中。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Boot 如何集成外部容器？", "output": "可以把 Spring Boot 项目打包成 WAR 并部署到外部 Tomcat 或 Jetty。也可以替换默认内嵌容器，让应用以传统方式运行。"}
{"system": "你是一名并发面试官。", "input": "什么是活锁？", "output": "活锁是线程不断让步或重试导致任务无法推进，状态在变化但不完成。例如线程一直互相让出资源。和死锁不同，活锁不会阻塞，但永远做不完。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是 TLAB？", "output": "TLAB 是每个线程独享的对象分配缓冲区，避免多线程竞争堆空间。对象优先在 TLAB 中分配，从而显著提升对象创建性能。"}
{"system": "你是一名 Java 面试官。", "input": "Java 的内存区域有哪些？", "output": "主要包括：堆（对象存储）、虚拟机栈（栈帧/局部变量）、本地方法栈（Native 调用）、方法区/元空间（类元数据）、程序计数器（当前线程执行位置）。"}
{"system": "你是一名 Java 面试官。", "input": "Spring 如何实现事件机制？", "output": "Spring 通过 ApplicationEventPublisher 发布事件，监听端通过 @EventListener 或 ApplicationListener 接收事件。底层基于观察者模式，实现业务解耦与异步事件处理。"}
{"system": "你是一名面试官。", "input": "如何做灰度发布？", "output": "常用策略包括按用户 ID、地区、版本、流量比例路由到新版本实例。一般通过 API Gateway、Service Mesh（如 Istio）、或 Nginx 做流量分流，实现平滑上线和风险可控。"}
{"system": "你是一名专业的Java后端面试官，请给出结构化、专业的回答。", "input": "什么是装箱和拆箱？", "output": "装箱是指基本类型转换为包装类型（int → Integer），拆箱则是包装类型转换回基本类型（Integer → int）。Java 提供自动装箱/拆箱语法糖，但频繁使用会生成大量临时对象并触发拆箱 NPE，需要谨慎使用。"}
{"system": "你是一名并发专家。", "input": "什么是线程池？", "output": "线程池是管理和复用线程的组件，避免频繁创建销毁线程，提高吞吐。通过 ThreadPoolExecutor 管理核心线程、队列和拒绝策略。适合高并发和任务量大的场景。"}
{"system": "你是一名并发专家。", "input": "IO 密集型任务线程数建议是多少？", "output": "一般建议 CPU 核心数的 2–4 倍，或根据公式：线程数 ≈ CPU 核心数 ×（1 + 阻塞系数）。阻塞越严重，线程数越多。"}
{"system": "你是一名网络通信专家。", "input": "TCP 的滑动窗口是什么？", "output": "滑动窗口是 TCP 的流量控制机制，允许发送方在无需等待 ACK 的情况下连续发送多个数据包。窗口根据接收方处理能力动态调整，从而提高链路吞吐。"}
{"system": "你是一名并发专家。", "input": "CyclicBarrier 与 CountDownLatch 的区别？", "output": "CyclicBarrier 可重置，且所有线程必须到达屏障点后一起继续；CountDownLatch 是一次性的，只有等待线程阻塞，计数归零后所有等待线程恢复。"}
{"system": "你是一名 Java 面试官。", "input": "什么是锁消除？", "output": "锁消除是 JIT 基于逃逸分析判断锁对象不会被其他线程访问，从而移除无意义的同步操作。能显著降低锁开销，提高执行效率。"}
{"system": "你是一名 Java 面试官。", "input": "为什么要使用双亲委派模型？", "output": "双亲委派确保核心类库不会被子 ClassLoader 覆盖，提高系统安全性；还能避免重复加载类，保持类定义的一致性。"}
{"system": "你是一名专业的Java后端面试官。", "input": "== 和 equals() 的区别是什么？", "output": "== 比较基本类型值、引用类型地址；equals() 默认与 == 一样，但常被重写用于内容比较，如 String、Integer。重写 equals() 时必须保持与 hashCode 一致性。"}
{"system": "你是一名 Java 面试官。", "input": "Java 中的 SPI 是什么？", "output": "SPI 是 Java 的服务提供者机制，用于通过接口 + 实现解耦，实现模块化、可插拔扩展。典型应用包括 JDBC、日志框架、Dubbo 等的动态加载实现。"}
{"system": "你是一名并发面试官。", "input": "CompletableFuture 和 Future 区别？", "output": "Future 只能阻塞获取结果，不支持链式组合。CompletableFuture 支持链式异步编排、回调、异常处理，并能与线程池灵活结合，实现强大的异步流程控制。"}
{"system": "你是一名系统设计面试官。", "input": "什么是服务网格（Service Mesh）？", "output": "Service Mesh 通过 Sidecar 模式将服务治理能力下沉到基础设施层，由数据平面（Envoy）与控制平面（Istio）协作提供流量管理、灰度发布、可观测性、安全（mTLS）等能力，无需业务侵入。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 如何避免缓存击穿？", "output": "可通过互斥锁（single flight）、热点 Key 设置永不过期、或使用逻辑过期方案。核心目标是避免大量请求同时击穿数据库。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是指针碰撞？", "output": "指针碰撞是一种快速的对象分配方式，当堆是连续内存时，只需移动分配指针即可完成对象分配。高效但依赖于堆无碎片，通常配合复制算法使用。"}
{"system": "你是一名专业面试官。", "input": "Redis 与 ZooKeeper 分布式锁的区别？", "output": "Redis 锁性能高、延迟低，但一致性较弱，需处理过期和主从切换问题；ZooKeeper 基于强一致性的临时顺序节点，可靠性高但吞吐较低。高吞吐偏向 Redis，高一致性偏向 ZK。"}
{"system": "你是一名 JUC 专家。", "input": "什么是 Work-Stealing？", "output": "Work-Stealing 是一种负载均衡策略，空闲线程会从其他线程的双端队列中“窃取”任务执行。它提升 CPU 利用率并减少线程间工作不均，典型实现是 ForkJoinPool。"}
{"system": "你是一名并发专家。", "input": "什么是 CAS？", "output": "CAS（Compare-And-Swap）是一种无锁原子操作，通过比较期望值与内存中值一致时再更新。它避免阻塞，但存在 ABA、自旋开销大、只能操作单变量等问题。"}
{"system": "你是一名 Java 面试官。", "input": "Redis Cluster 什么是 hash slot？", "output": "Redis Cluster 将数据划分为 16384 个 hash slot，每个 slot 由某个节点负责。通过 CRC16(key) % 16384 计算 slot，实现数据分布与水平扩容。"}
{"system": "你是一名并发专家。", "input": "ConcurrentHashMap 与 HashTable 区别？", "output": "Hashtable 使用全表锁，性能低；ConcurrentHashMap 采用分段锁或 CAS + synchronized，支持高并发访问。整体性能和扩展性远优于 Hashtable。"}
{"system": "你是一名 Java 面试官。", "input": "什么是不可变对象？", "output": "不可变对象创建后状态不可修改，如 String、Integer、LocalDate。优点是天然线程安全、可缓存、简化并发模型，特别适合多线程场景和函数式编程."}
{"system": "你是一名专业 Java 面试官。", "input": "Redis 中的 SDS 是什么？", "output": "SDS（Simple Dynamic String）是 Redis 的字符串结构，支持 O(1) 获取长度、预分配空间避免频繁扩容、二进制安全，并且能防止 C 字符串的缓冲区溢出问题。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是 Minor GC？", "output": "Minor GC 是发生在新生代的垃圾回收，主要清理 Eden 区。频率高但速度快，因为新生代大部分对象都存活时间很短。"}
{"system": "你是一名 Java 面试官。", "input": "什么是枚举 enum？", "output": "enum 是一种特殊类，用于表示固定常量集合，天然线程安全。枚举可用于实现单例，并且能避免反射和反序列化破坏。"}
{"system": "你是一名 Java 面试官。", "input": "Spring MVC 如何参数绑定？", "output": "Spring MVC 通过 HandlerMethodArgumentResolver 把请求数据转换为控制器方法参数。它支持基本类型、JavaBean、路径变量、Query 参数以及 @RequestBody 的 JSON 反序列化。整个绑定过程都是自动完成的。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 MyBatis 插件机制？", "output": "MyBatis 插件通过拦截器机制增强 Executor、StatementHandler、ParameterHandler、ResultSetHandler 等组件。可实现分页、审计、加密等横切逻辑。"}
{"system": "你是一名 Java 面试官。", "input": "@ComponentScan 的作用是什么？", "output": "@ComponentScan 用来指定要扫描的包路径，把标注了 @Component、@Service、@Repository、@Controller 等注解的类自动注册为 Spring Bean。它是 Spring 自动装配能力的基础之一。"}
{"system": "你是一名架构面试官。", "input": "什么是缓存击穿？", "output": "热点 key 过期后瞬间大量流量落到数据库导致压力激增。解决方案包括互斥锁（single flight）和逻辑过期等方式保证只有一个线程重建缓存。"}
{"system": "你是一名专业面试官。", "input": "什么是服务雪崩？", "output": "服务雪崩是下游服务故障导致上游不断重试、排队、阻塞，最终整条调用链都被拖垮的问题。典型应对包括熔断、限流、降级、隔离（线程池/舱壁模式）、超时控制和快速失败策略。"}
{"system": "你是一名系统设计专家。", "input": "什么是可观测性？", "output": "可观测性由日志（Logs）、指标（Metrics）和链路追踪（Traces）组成。目标是让系统的内部状态可被理解，从而快速定位问题。它是现代分布式系统的必要能力。"}
{"system": "你是一名专业 Java 面试官。", "input": "复制算法为什么适合新生代？", "output": "新生代大部分对象很快死亡，存活对象极少，复制成本低。复制算法不需要整理碎片，回收速度快，适合频繁 GC 的新生代。"}
{"system": "你是一名专业 Java 面试官。", "input": "指令重排序是什么？", "output": "指令重排序是编译器或 CPU 为优化性能，对指令执行顺序进行调整的行为。它必须保持单线程语义不变，但在多线程环境中可能导致可见性与有序性问题（如 DCL 单例）。"}
{"system": "你是一名 Java 面试官。", "input": "如何查看 JVM 线程堆栈？", "output": "使用 jstack <pid> 就能查看 JVM 当前所有线程的堆栈信息，用于排查死锁、阻塞和 CPU 过高问题。也可以结合 jmap、jcmd 做更深层分析。"}
{"system": "你是一名 Java 面试官。", "input": "为什么 ConcurrentHashMap 规模大时扩容仍然快？", "output": "因为扩容采用分段迁移（transfer task），桶级迁移由多个线程共同完成；同时使用 CAS、ForwardingNode 等机制减少锁竞争，从而在大容量下依然保持高性能扩容。"}
{"system": "你是一名专业架构师。", "input": "分布式 ID 生成方案有哪些？", "output": "常见方案包括数据库自增、UUID、Redis 原子递增、雪花算法、ZooKeeper 顺序节点。综合性能与可扩展性，雪花算法最常用，具有高性能、趋势递增、可分布式部署等优势。"}
{"system": "你是一名网络通信专家。", "input": "什么是 WebSocket？", "output": "WebSocket 是基于 TCP 的全双工通信协议，通过 HTTP 握手升级后保持长连接，适用于实时推送，如IM 聊天、行情推送、游戏同步等。"}
{"system": "你是一名 Java 面试官。", "input": "Optional 的作用是什么？", "output": "Optional 用于包装可能为 null 的值，通过链式调用避免显式 null 判断，提高可读性。适用于返回值，不建议滥用在字段或集合中。"}
{"system": "你是一名 Java 面试官。", "input": "为什么 MySQL 使用 redo log？", "output": "redo log 支持 WAL（Write-Ahead Logging），先写日志再写数据，实现崩溃恢复。确保事务的持久性，避免异常宕机导致数据丢失。"}
{"system": "你是一名 Java 面试官。", "input": "什么是堆和栈？", "output": "栈用于存放局部变量和方法调用信息，是线程私有的，访问速度快但容量较小。堆存放对象实例，为线程共享，由 GC 管理，空间更大但访问较慢。"}
{"system": "你是一名架构面试官。", "input": "什么是 CDN？", "output": "CDN 是内容分发网络，通过在全球部署边缘节点缓存静态资源，减少回源请求。能提升访问速度、降低延迟、减轻源站压力、增强可用性。"}
{"system": "你是一名专业 Java 面试官。", "input": "JMM 中的三大特性是什么？", "output": "可见性确保变量更新对其他线程立即可见；有序性通过内存屏障限制指令重排；原子性保证基本操作不可被中断，是并发安全的基础。"}
{"system": "你是一名专业 Java 面试官。", "input": "如何解决 ABA 问题？", "output": "通过引入版本号解决，例如使用 AtomicStampedReference 或 AtomicMarkableReference。每次更新携带版本信息，使 A→B→A 的变化被检测到。"}
{"system": "你是一名 Java 面试官。", "input": "MySQL MVCC 是什么？", "output": "MVCC 是多版本并发控制，通过 undo log 和 ReadView 实现快照读。它避免读加锁，提高读写并发，让 REPEATABLE READ 下读到一致性视图而不阻塞写。"}
{"system": "你是一名并发面试官。", "input": "什么是轻量级锁？", "output": "轻量级锁通过 CAS 将对象头 MarkWord 指向当前线程的锁记录，实现自旋而非阻塞。适用于竞争不激烈的场景，减少线程上下文切换，提高性能。"}
{"system": "你是一名专业 Java 面试官。", "input": "volatile 的使用场景是什么？", "output": "volatile 适用于轻量级同步，如状态标记、单例双重检查、开关控制、多线程可见性要求高但不涉及复合操作的场景。"}
{"system": "你是一名架构面试官。", "input": "为什么要使用消息队列？", "output": "消息队列用于系统解耦、异步化、削峰填谷、提高可靠性（重试机制）、平滑流量压力。适合高并发与复杂架构场景。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是 this 和 super？", "output": "this 指向当前对象，用于访问本类属性、方法或调用构造器。super 指向父类对象，用于调用父类方法或构造器，解决隐藏或重写问题。"}
{"system": "你是一名 Java 面试官。", "input": "如何避免死锁？", "output": "合理规划加锁顺序、使用 tryLock 加超时、缩小锁粒度或合并锁。还能使用并发容器替代手写锁，降低发生死锁的可能性。"}
{"system": "你是一名专业架构师。", "input": "ZooKeeper 分布式锁原理是什么？", "output": "ZK 通过创建临时顺序节点实现锁竞争，节点序号最小者获得锁。失败的客户端监听前驱节点删除事件，避免轮询，既公平又避免死锁，具备天然的高可用特性。"}
{"system": "你是一名专业 Java 面试官。", "input": "Java 为什么不使用引用计数法？", "output": "引用计数无法处理循环引用，会导致内存泄漏；维护计数本身也有较高开销。Java 选择可达性分析，通过 GC Roots 避免循环引用问题，整体更高效可靠。"}
{"system": "你是一名网络专家。", "input": "Netty 的 Reactor 模型是什么？", "output": "Netty 采用多 Reactor 模型：包括单 Reactor、Reactor 多线程、主从 Reactor。通过事件分发+回调机制处理 Accept、Read、Write，提高并发处理能力。"}
{"system": "你是一名网络专家。", "input": "HTTP2 为什么能更快？", "output": "HTTP2 通过多路复用消除队头阻塞、使用二进制帧减少解析开销、头部压缩降低带宽占用，并支持服务器推送减少 RTT，因此整体性能显著提升。"}
{"system": "你是一名 Java 面试官。", "input": "什么是断言 assert？", "output": "assert 是一种调试辅助，用来断言某个条件必须为真，否则抛 AssertionError。它默认关闭，需添加 -ea 启用，不建议在生产环境依赖其做业务校验。"}
{"system": "你是一名 Java 专业面试官。", "input": "try-catch-finally 的执行顺序是什么？", "output": "代码先进入 try，如果有异常且匹配会执行 catch。finally 一定会执行，除非进程被终止。即便 try/catch 有 return，也会在 finally 执行后再返回。"}
{"system": "你是一名网络专家。", "input": "TCP 与 UDP 在应用层如何选择？", "output": "需要可靠、有序传输（如文件、支付、登录）选 TCP；需要低延迟实时性（如游戏、直播、语音）选 UDP；需要广播/多播也选择 UDP。最终取决于可靠性 vs 性能的权衡。"}
{"system": "你是一名 JUC 面试官。", "input": "什么是 CLH 队列？", "output": "CLH 队列是 AQS 使用的双向 FIFO 等待队列，通过自旋和前驱节点的锁状态协调线程获取锁。它避免大量线程同时自旋，提高锁的吞吐和可伸缩性。"}
{"system": "你是一名专业面试官。", "input": "为什么是三次握手而不是两次？", "output": "三次握手能同时确认双方发送与接收能力是否正常，两次握手无法确认客户端的接收能力，可能导致历史连接（旧 SYN）造成资源浪费。"}
{"system": "你是一名 Java 面试官。", "input": "什么是意向锁？", "output": "意向锁是 InnoDB 的表级锁，用于告诉数据库当前事务打算对某行加什么类型的行锁。它不与行锁冲突，只与其他表级锁冲突，从而快速判断是否能加锁，提高锁检测效率。"}
{"system": "你是一名专业面试官。", "input": "HTTP 和 HTTPS 的区别？", "output": "HTTPS = HTTP + SSL/TLS，提供加密、防篡改和身份认证；默认端口 443。相比 HTTP 更安全但 CPU 和握手开销更高。"}
{"system": "你是一名 Java 面试官。", "input": "浅拷贝和深拷贝的区别？", "output": "浅拷贝仅复制对象本身，内部引用指向同一实例；深拷贝会连同引用对象一起复制，两者互不影响。浅拷贝适合不可变对象，深拷贝适合需要数据隔离的场景。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是 JVM 分代设计？", "output": "JVM 将堆按对象生命周期划分为新生代（Eden + Survivor）和老年代。基于“绝大多数对象朝生夕死”的假设，提高 GC 效率，新生代采用复制算法，老年代采用标记整理或标记清除。"}
{"system": "你是一名 Java 面试官。", "input": "Sentinel 的核心功能是什么？", "output": "Sentinel 提供限流、熔断降级、隔离与系统自适应保护能力。基于滑动窗口进行实时统计，通过规则动态保护系统的稳定性。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 defineClass？", "output": "defineClass 是自定义类加载器用于把字节码数组转换成 Class 对象的方法。常用于动态生成类、字节码增强、热加载等场景。是 Java 类加载机制的底层入口之一。"}
{"system": "你是一名 Java 面试官。", "input": "Optional 可能带来什么问题？", "output": "Optional 过度使用会造成额外对象创建开销，不适合用作类字段或高频调用场景。更适合作为方法返回值避免 NullPointerException。"}
{"system": "你是一名并发专家。", "input": "什么是线程上下文切换？", "output": "线程上下文切换指 CPU 保存当前线程状态并切换到另一个线程执行。开销包括寄存器状态保存、TLB 刷新、CPU cache 失效，因此频繁切换会降低性能。"}
{"system": "你是一名分布式面试官。", "input": "什么是负载均衡层（LB 层）？", "output": "LB 层位于流量入口，用 Nginx、F5、Envoy 等反向代理或硬件负载均衡器将流量按规则分配给后端节点。它提高系统的吞吐、可用性和容错能力。"}
{"system": "你是一名专业 Java 面试官。", "input": "volatile 的使用场景是什么？", "output": "volatile 适用于轻量级同步，如状态标记、单例双重检查、开关控制、多线程可见性要求高但不涉及复合操作的场景。"}
{"system": "你是一名 Java 面试官。", "input": "反射的用途是什么？", "output": "反射用于在运行时动态获取类信息并操作对象，常见场景包括 Spring 依赖注入、MyBatis 映射、插件化扩展、动态代理与 AOP 等框架级能力。"}
{"system": "你是一名系统设计专家。", "input": "如何设计高可用缓存系统？", "output": "关键要点包括：多副本与主从同步、Redis 哨兵/Cluster、应用端多级缓存（本地+Redis）、一致性哈希减少重分布、热点隔离与自动扩容、缓存预热和降级策略。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 JDK8 的时间 API？", "output": "JDK8 时间 API 包含 LocalDate、LocalTime、LocalDateTime、Instant、Duration、Period 等类型，全部是线程安全和不可变的。它们基于 ISO 标准，提供更清晰的时间表达和强类型 API，避免旧版 Date/Calendar 的线程安全和语义混乱问题。"}
{"system": "你是一名网络专家。", "input": "什么是非阻塞 IO？", "output": "非阻塞 IO 调用会立即返回，即使数据没准备好也不会卡住线程。应用需要不断轮询或结合多路复用才能获取到真正可读写的状态。它的优点是线程利用率高，适合高并发场景。"}
{"system": "你是一名网络通信专家。", "input": "ARP 协议作用是什么？", "output": "ARP 用于在局域网中根据 IP 地址解析出目标设备的 MAC 地址，通过广播询问并由目标主机应答完成解析。"}
{"system": "你是一名 Java 面试官。", "input": "什么是晋升失败？", "output": "当 Minor GC 后存活对象需要晋升到老年代，但 Survivor 或老年代空间不足，就会发生晋升失败。此时 JVM 会触发 Full GC 尝试腾出空间。"}
{"system": "你是一名 Java 面试官。", "input": "如何排查 MySQL 死锁？", "output": "使用 SHOW ENGINE INNODB STATUS 查看死锁日志，分析锁等待链和冲突的事务。重点关注持有锁与等待锁的行记录、事务隔离级别、SQL 执行顺序，然后通过索引优化或调整访问顺序解决。"}
{"system": "你是一名架构师。", "input": "为什么使用缓存？", "output": "缓存能显著降低数据库压力，提高读性能和吞吐量。还能增强系统可用性，即使后端偶尔不可用也能抗住一部分流量。适合热点数据、高频访问场景。"}
{"system": "你是一名 Java 面试官。", "input": "ABA 问题怎么解决？", "output": "使用 AtomicStampedReference 或带版本号（version）的 CAS，确保比较时不仅检查值，还检查版本或时间戳。"}
{"system": "你是一名专业面试官。", "input": "UUID 为什么不适合作数据库主键？", "output": "UUID 过于随机会导致索引严重碎片化，破坏 B+Tree 局部性；占用空间大，不利排序；写入性能明显下降。因此一般使用自增ID或雪花算法。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 事务支持原子性吗？", "output": "Redis 事务 MULTI/EXEC 保证命令的批量原子执行，但不支持回滚。入队失败会直接报错，执行阶段的错误不会全部回滚，因此不能保证传统 ACID 的完整原子性。"}
{"system": "你是一名架构面试官。", "input": "什么是死信队列？", "output": "死信队列用于存放无法被正常消费的消息，例如超时、被拒绝或重试失败的消息。它方便后续排查和补偿，常用于提高消息系统可靠性。"}
{"system": "你是一名 Java 面试官。", "input": "@RestController 和 @Controller 的区别？", "output": "@RestController 等同于 @Controller + @ResponseBody，所有方法默认返回 JSON。@Controller 用于 MVC 场景，一般返回页面模板或手动加 @ResponseBody。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka Consumer Rebalance 是什么？", "output": "Rebalance 是消费者组内分区的重新分配，当消费者加入、离开或订阅变更时触发。Rebalance 保证每个分区只被一个消费者消费，实现负载均衡。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 MyBatis？", "output": "MyBatis 是半 ORM 框架，通过 XML 或注解绑定 SQL，将结果映射为对象。适合手写 SQL、复杂查询场景，灵活高效。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka 如何保证至少一次消费？", "output": "先处理消息再提交 offset，当提交失败或重复拉取时会导致重复消费。通过幂等操作保证业务正确性。"}
{"system": "你是一名网络面试官。", "input": "什么是粘包与拆包？", "output": "TCP 是面向字节流协议，不保留消息边界，因此多条消息可能被合并为一条（粘包）或被拆成多段（拆包）。需要在应用层自定义协议，如使用长度字段、固定长度、分隔符等方式解决。"}
{"system": "你是一名并发专家。", "input": "什么是死锁？", "output": "死锁是多个线程相互占有对方需要的锁而无限等待，导致程序无法继续推进的状态。它满足四个必要条件：互斥、占有并等待、不可抢占、循环等待。只要破坏任意一个条件就能避免死锁。"}
{"system": "你是一名分布式面试官。", "input": "什么是服务注册与发现？", "output": "服务注册中心维护服务实例列表，服务启动时注册自身，消费者从注册中心拉取可用实例地址。典型组件包括 Eureka、Nacos、Consul 和 Zookeeper，实现动态服务治理。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 Class.forName？", "output": "Class.forName 会加载类并触发静态块和静态变量初始化，常用于 SPI 或 JDBC 驱动注册。它与 ClassLoader.loadClass 的区别就在于是否执行初始化阶段。"}
{"system": "你是一名专业架构师。", "input": "什么是幂等性？如何设计？", "output": "幂等性指同一操作多次执行结果一致。常见设计方案包括：唯一业务 ID（如订单号）、幂等表/去重表、基于状态机的条件更新、分布式锁、消息去重、重试 token 等。"}
{"system": "你是一名网络通信专家。", "input": "什么是同步 IO 与异步 IO？", "output": "同步 IO 指线程发起请求后必须等待内核完成操作；异步 IO 则是内核完成后主动通知线程。异步 IO 能让线程不被阻塞，更适合高并发和 IO 密集业务。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka Producer 如何提高吞吐？", "output": "可通过增大 batch.size、适当提高 linger.ms、启用压缩（compression.type=gzip/snappy/lz4）、acks=1 或 0、减少同步 flush 等方式提升吞吐。"}
{"system": "你是一名 Java 面试官。", "input": "什么是动态代理？", "output": "动态代理是在运行时生成代理对象拦截方法调用。JDK Proxy 基于接口，CGLIB 基于子类生成，可代理无接口类。常用于 AOP、RPC、日志与监控增强。"}
{"system": "你是一名 Java 面试官。", "input": "什么时候需要破坏双亲委派？", "output": "典型场景包括：SPI 机制（如 JDBC 驱动加载）、插件系统、热部署/热替换、自定义类加载逻辑等。目的是让子类加载器优先加载特定类。"}
{"system": "你是一名 Java 面试官。", "input": "ArrayList 和 LinkedList 的区别？", "output": "ArrayList 基于动态数组，支持 O(1) 随机访问；LinkedList 基于双向链表，适合频繁插入删除但随机访问慢。一般大多数场景都推荐使用 ArrayList。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Bean 的生命周期是什么？", "output": "流程包括：实例化 → 属性注入 → Aware 接口回调 → BeanPostProcessor 前置 → 初始化（@PostConstruct/init-method）→ 后置处理 → 业务运行 → 销毁（@PreDestroy/destroy-method）。"}
{"system": "你是一名 Java 面试官。", "input": "如何查看内存使用情况？", "output": "常用工具包括 jmap（堆dump）、jstat（GC与内存）、VisualVM 与 JProfiler 可视化分析、MAT 用于分析堆泄漏。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是安全点（Safe Point）？", "output": "Safe Point 是 JVM 可以安全暂停线程的位置，用于 GC、偏向锁撤销等操作。常见 Safe Point 包括方法调用、循环回跳、异常处理等，以确保堆和线程栈的一致性。"}
{"system": "你是一名 Java 面试官。", "input": "过滤器和拦截器有什么区别？", "output": "过滤器基于 Servlet 规范，属于容器层，能拦截所有请求，包括静态资源。拦截器基于 Spring MVC，只作用于进入 Controller 的请求。过滤器更底层，拦截器更灵活、与业务更贴近。"}
{"system": "你是一名 Java 面试官。", "input": "什么是对象的生命周期？", "output": "对象生命周期包括：创建 → 使用 → 不可达 → GC 回收。Java 通过垃圾回收机制自动管理对象的内存释放。"}
{"system": "你是一名 Java 面试官。", "input": "Java 中的 BigDecimal 有什么用途？", "output": "BigDecimal 用于高精度数值计算，典型应用是金融领域的金额计算。建议使用字符串构造避免 double 带来的精度误差，并注意舍入方式和 scale 设置。"}
{"system": "你是一名 Java 面试官。", "input": "Redis Stream 有哪些优势？", "output": "Redis Stream 提供消费组、消息确认、阻塞读取、持久化以及死信处理等能力，是 Redis 原生的高性能消息队列方案。相比 List 或 Pub/Sub，它支持可靠消费和水平扩展，更适合业务级消息处理。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 GC overhead limit exceeded？", "output": "当 JVM 超过 98% 的时间都在 GC 且回收不到 2% 的内存时，会抛出 GC overhead limit exceeded，表示应用基本无法继续运行。"}
{"system": "你是一名 Java 面试官。", "input": "什么是类初始化顺序？", "output": "初始化顺序是：父类静态代码 → 子类静态代码 → 父类实例代码 → 子类实例代码 → 构造方法。静态先于实例，只执行一次。这个顺序在调试类加载问题时很关键。"}
{"system": "你是一名架构师。", "input": "什么是事件溯源（Event Sourcing）？", "output": "事件溯源通过记录状态变更事件而非直接记录最终状态，系统可通过事件重放恢复任意时间点的状态。适用于金融、电商等需要审计、回放、强一致性的场景，并自然支持 CQRS。"}
{"system": "你是一名 Java 面试官。", "input": "什么是可重入锁？", "output": "可重入锁允许同一线程在持有锁的情况下再次获取同一把锁，避免重复加锁导致死锁。Java 的 synchronized 和 ReentrantLock 都支持可重入性。"}
{"system": "你是一名并发专家。", "input": "什么是临界区？", "output": "临界区是访问共享资源的代码片段，若无同步会产生竞态。必须通过锁、信号量等机制保护，使其同一时间只被一个线程执行。"}
{"system": "你是一名 Java 面试官。", "input": "MyBatis 中 #{} 和 ${} 的区别是什么？", "output": "#{} 会进行预编译并使用占位符，能防 SQL 注入；${} 直接字符串拼接，存在注入风险，一般用于动态表名或列名。"}
{"system": "你是一名 Java 面试官。", "input": "如何判断一个对象是否“年轻”？", "output": "通过对象在 Survivor 区的年龄（age）判断；每经历一次 Minor GC，存活对象 age+1。达到阈值（默认 15）会晋升到老年代。"}
{"system": "你是一名网络专家。", "input": "HTTP1.1 与 HTTP2 的区别？", "output": "HTTP2 采用二进制帧、多路复用、头部压缩（HPACK）与服务端推送，大幅提升性能。HTTP1.1 基于文本协议，存在队头阻塞且无多路复用能力。"}
{"system": "你是一名 Java 面试官。", "input": "synchronized 和 Lock 的区别？", "output": "synchronized 是 JVM 级别，语法简单、自动释放锁；Lock 是 API 级别，支持可中断、公平锁、tryLock、读写锁等更灵活的特性。Lock 性能更可控，但需手动 unlock。"}
{"system": "你是一名网络面试官。", "input": "什么是 TCP 重传机制？", "output": "TCP 重传包括超时重传（RTO 超时触发）和快速重传（连续收到 3 个重复 ACK 判断丢包）。快速重传更快，无需等待超时，是高吞吐场景下的重要机制。"}
{"system": "你是一名专业面试官。", "input": "什么是事件驱动架构？", "output": "事件驱动架构通过事件在系统间传播，通常依赖 MQ。生产者发布事件，消费者异步处理，从而实现系统解耦、削峰和弹性扩展。非常适合高并发和松耦合场景。"}
{"system": "你是一名专业架构师。", "input": "如何设计一个秒杀系统的数据库？", "output": "通常采用分库分表、库存分段（或预扣库存）、热点数据隔离、行级乐观锁、异步削峰写入（MQ）、读写分离与限流降级。关键是削峰填谷与减少对单点库存的竞争。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 Math.random()？", "output": "Math.random() 用的是共享的 Random 实例，生成伪随机数。由于内部 Random 线程不安全，在高并发场景下推荐用 ThreadLocalRandom 或 SplittableRandom，性能更高也更安全。"}
{"system": "你是一名 Java 面试官。", "input": "如何查看 GC 日志？", "output": "在 JVM 启动参数中添加 -Xlog:gc*（JDK9+）或 -XX:+PrintGCDetails（JDK8）。启动后即可观察 GC 次数、停顿时间、内存回收情况，用于诊断内存与性能问题。"}
{"system": "你是一名专业 Java 面试官。", "input": "Java 中的继承有什么限制？", "output": "Java 只支持单继承，一个类只能继承一个父类，但可实现多个接口。这样避免菱形继承问题，提升可维护性，复杂场景通常通过组合优于继承的方式扩展能力。"}
{"system": "你是一名网络面试官。", "input": "什么是跨域？如何解决？", "output": "跨域是浏览器基于同源策略禁止不同域之间的请求访问。常见解决方式包括：CORS（最标准）、反向代理（如 Nginx 转发）、JSONP（仅支持 GET），以及设置 nginx 或网关的跨域头。"}
{"system": "你是一名 Java 面试官。", "input": "@Transactional 的失效场景有哪些？", "output": "@Transactional 常见失效场景包括：方法不是 public、自调用绕过代理、异常被捕获未抛出、final 方法无法代理、以及在多线程/异步场景下代理不可见。核心原因都是代理机制未生效或异常无法触发回滚。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Cloud Bus 的作用是什么？", "output": "Spring Cloud Bus 基于 MQ 广播配置刷新事件，实现分布式系统配置的统一热更新。常与 Config Server 结合使用。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Bean 的作用域有哪些？", "output": "Spring Bean scope 包括：singleton（默认，整个容器一个实例）、prototype（每次注入新实例）、request、session、application（Web 环境下）。通常无状态 Bean 使用 singleton。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 Seata？", "output": "Seata 是阿里开源的分布式事务框架，提供 AT、TCC、Saga、XA 等模式。它通过 TC/TC/DB 协同实现分布式场景的一致性控制。"}
{"system": "你是一名 Java 面试官。", "input": "什么是锁粗化？", "output": "锁粗化将多个连续的小范围加锁合并为一个大范围加锁，减少频繁加解锁的开销，提高吞吐。典型例子是循环内频繁追加字符串。"}
{"system": "你是一名 Java 面试官。", "input": "泛型的上界和下界是什么？", "output": "? extends T 限定上界用于生产者（可读不可写），? super T 限定下界用于消费者（可写不可读）。遵循 PECS 原则：Producer Extends，Consumer Super。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 JIT？", "output": "JIT（Just-In-Time）是 JVM 的即时编译器，它会把热点字节码在运行时动态编译成机器码。这样避免频繁解释执行，提升吞吐和整体性能，是 JVM 性能优化的核心机制之一。"}
{"system": "你是一名 Java 面试官。", "input": "枚举如何实现单例？", "output": "枚举天然就是单例，JVM 会保证枚举实例只创建一次，并且不会被反射或反序列化破坏。写法简单且最安全，是实现单例模式的最佳方式之一。"}
{"system": "你是一名专业架构面试官。", "input": "什么是分布式锁？", "output": "分布式锁用于在多节点环境下保证对共享资源的互斥访问。典型实现包括：Redis 锁（SET NX PX + 校验删除）、Zookeeper 临时顺序节点锁、数据库基于唯一约束的乐观/悲观锁。"}
{"system": "你是一名架构面试官。", "input": "什么是 CQRS？", "output": "CQRS（命令查询职责分离）将写操作（Command）与读操作（Query）分开处理。写模型保持强一致，读模型可通过缓存、索引或副本加速访问。适用于高并发、读多写少的系统，增强扩展性与可维护性。"}
{"system": "你是操作系统专家。", "input": "什么是系统调用？", "output": "系统调用是用户态程序进入内核态执行特权操作的唯一方式，例如文件 IO、网络通信、进程管理。通过软中断或 syscall 指令完成权限切换。"}
{"system": "你是一名架构面试官。", "input": "什么是限流？为什么需要限流？", "output": "限流用于控制请求并发量或 QPS，防止系统过载崩溃。常见算法包括令牌桶、漏桶、固定窗口和滑动窗口。其目标是保护核心服务并提升系统稳定性。"}
{"system": "你是一名 Java 面试官。", "input": "Spring 三级缓存解决循环依赖原理是什么？", "output": "Spring 通过三级缓存：singletonObjects（成品对象）、earlySingletonObjects（半成品对象）、singletonFactories（对象工厂）提前暴露代理，解决 Setter 注入循环依赖。关键是三级缓存允许提前创建未完全初始化的 Bean。"}
{"system": "你是一名系统设计面试官。", "input": "如何设计 100 万 QPS 的接口？", "output": "核心手段包括多级缓存（本地+Redis+CDN）、负载均衡、异步化与削峰、连接池优化、限流熔断、横向扩容、多分区架构、批处理与合并请求。最终目标是减少 IO、降低延迟并增强扩展性。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 JVM 逃逸分析？", "output": "逃逸分析用于判断对象作用域，若对象未逃出方法，可进行栈上分配；若未逃出线程，可做锁消除和标量替换，大幅减少堆分配和锁竞争。"}
{"system": "你是一名专业面试官。", "input": "什么是心跳检测？", "output": "心跳检测是实例定期向服务端上报存活信号。若连续多次超时，注册中心会判定实例宕机并摘除。用于保持服务健康与动态上下线。"}
{"system": "你是一名 Java 面试官。", "input": "什么是死锁？", "output": "死锁是多个线程相互等待对方持有的资源，导致无法继续执行。它具备互斥、占有且等待、不可抢占、循环等待四个条件。"}
{"system": "你是一名 Java 面试官。", "input": "Seata AT 模式的原理是什么？", "output": "AT 模式通过解析业务 SQL 生成 before/after image，并在 TC 记录 undo log。提交阶段异步清理，回滚时根据 before image 恢复数据，实现自动化的分布式事务，无需业务侵入。"}
{"system": "你是一名 Java 面试官。", "input": "Java 中的 Date 和 Calendar 有什么问题？", "output": "Date 和 Calendar 设计混乱、线程不安全且不可变性差。JDK8 推出的 java.time 包提供更清晰、线程安全的时间 API。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 fail-fast？", "output": "fail-fast 指迭代集合时如果结构被并发修改，会立刻抛 ConcurrentModificationException。它能快速暴露问题，而不是返回不可预测的结果。多线程场景需用并发集合避免该问题。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Cloud 常见的负载均衡策略有哪些？", "output": "包括轮询、随机、权重、最小连接数、基于元数据的路由、哈希一致性等策略。Spring Cloud LoadBalancer 也支持自定义策略扩展。"}
{"system": "你是一名 Java 面试官。", "input": "Spring 容器有哪些类型？", "output": "Spring 核心容器包括 BeanFactory 和 ApplicationContext。BeanFactory 更轻量，负责基本 IoC；ApplicationContext 功能更全，支持国际化、事件、AOP、自动装配等，是实际开发的主流选择。"}
{"system": "你是一名 Java 面试官。", "input": "volatile 关键字有什么作用？", "output": "volatile 保证变量的可见性和一定的有序性（通过内存屏障），但不保证原子性。常用于状态标记、双重检查单例等轻量同步场景。"}
{"system": "你是一名 Java 面试官。", "input": "为什么 main 方法必须是 static？", "output": "因为 Java 程序启动时没有任何对象实例，JVM 需要直接通过类调用 main 方法，因此必须声明为 static，否则无法作为程序入口。"}
{"system": "你是一名并发专家。", "input": "CountDownLatch 用来做什么？", "output": "CountDownLatch 用于让一个或多个线程等待其他线程任务完成。计数减到 0 时所有等待线程继续执行。一次性工具，不能重置。"}
{"system": "你是一名专业 Java 面试官。", "input": "为什么 JDK8 把永久代改成元空间？", "output": "永久代容量固定且难以管理，容易导致类元数据 OOM。元空间使用本地内存，更灵活，垃圾回收更高效，也减少了类加载相关异常。"}
{"system": "你是一名网络面试官。", "input": "HTTPS 一定安全吗？", "output": "HTTPS 理论上更安全，但仍可能受中间人攻击（伪造证书）、弱密码套件、证书过期或错误配置影响。安全依赖于正确的证书链和协议配置。"}
{"system": "你是一名 Java 面试官。", "input": "为什么要使用 API Gateway？", "output": "API Gateway 作为统一入口，可集中处理路由、认证鉴权、限流熔断、监控日志、协议转换等能力。它将通用治理从业务中剥离，提高可扩展性、安全性与可观测性，是微服务架构的标配组件。"}
{"system": "你是一名 Java 面试官。", "input": "Feign 与 RestTemplate 的区别？", "output": "Feign 是声明式 HTTP 客户端，写接口就能调用，支持拦截器和负载均衡，集成度高。RestTemplate 是命令式调用，需要手写 URL、参数等，灵活但代码量大。整体上微服务场景更推荐 Feign。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 的内存淘汰依据是什么？", "output": "Redis 根据 key 的 TTL、访问频率（LFU）、访问时间（LRU）等指标执行淘汰策略。策略包括 volatile-lru、allkeys-lru、volatile-ttl、allkeys-random、noeviction 等。"}
{"system": "你是一名并发面试官。", "input": "volatile 关键字保证什么？", "output": "volatile 能保证可见性和有序性，通过内存屏障禁止重排序。但不保证操作的原子性，例如 i++ 仍需加锁或使用原子类。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 MyBatis 的动态 SQL？", "output": "动态 SQL 允许根据条件动态生成 SQL 语句，典型标签有 <if>、<choose>、<where>、<foreach>。适合多条件查询、批量操作等复杂 SQL 场景。"}
{"system": "你是一名 Java 面试官。", "input": "注解的生命周期有哪些？", "output": "注解生命周期包括：SOURCE（编译前有效）、CLASS（编译后保留，运行时不可见）、RUNTIME（运行时可读取，是框架最常用的级别）。"}
{"system": "你是一名并发专家。", "input": "什么是 Disruptor？", "output": "Disruptor 是高性能无锁队列，基于环形缓冲区与 CAS 实现，避免伪共享与锁竞争。延迟极低，常用于证券、交易等高频场景。"}
{"system": "你是一名 Java 面试官。", "input": "Java 中如何生成随机数？", "output": "常用 Random、ThreadLocalRandom 和 SecureRandom。ThreadLocalRandom 适合并发场景，SecureRandom 基于安全熵源，用于安全相关场景。"}
{"system": "你是一名 Java 面试官。", "input": "ZGC 的特点是什么？", "output": "ZGC 具备亚毫秒级停顿、几乎全程并发、支持并发压缩，并通过染色指针减少对象标记成本。适用于低延迟、大内存场景。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 分布式锁有哪些问题？", "output": "常见问题包括：锁过期导致误释放、主从复制延迟导致锁丢失、不可重入、不可公平、容错弱。一般使用 Redisson 的 RedLock 或延续机制来优化可靠性。"}
{"system": "you are a 专家。", "input": "什么是孤儿进程？", "output": "孤儿进程是父进程退出但子进程仍在运行的情况，此时子进程会被 init（PID 1）接管并回收其退出状态。"}
{"system": "你是一名专业 Java 面试官。", "input": "JVM 的运行时数据区有哪些？", "output": "JVM 运行时数据区包括：1）程序计数器；2）虚拟机栈；3）本地方法栈；4）堆；5）方法区/元空间；6）运行时常量池。前三者线程私有，堆和方法区线程共享。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 HikariCP？为什么快？", "output": "HikariCP 是高性能 JDBC 连接池。快的原因包括：轻量级实现、减少锁竞争、优化并发结构、快速健康检查、直接内联热点路径等。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 的 RDB 是什么？", "output": "RDB 是 Redis 的快照持久化方式，会在指定时间间隔把内存数据写入 RDB 文件。优点是文件小、恢复快，缺点是可能丢失最近一次快照之后的数据。"}
{"system": "你是一名专业的Java后端面试官，请给出结构化、简洁、专业的回答。", "input": "Java 的基本数据类型有哪些？", "output": "Java 基本数据类型共有 8 个：\n1）整数：byte、short、int、long\n2）浮点：float、double\n3）字符：char\n4）布尔：boolean\n它们存储在栈或对象内部，性能高且不需要 GC。"}
{"system": "你是一名技术面试官。", "input": "常见负载均衡算法有哪些？", "output": "包括轮询、随机、加权轮询、最少连接、一致性哈希、基于响应时间、自定义策略等。不同算法适用于不同业务场景。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka 为什么不支持“读写分离”？", "output": "因为 Kafka 要保证分区内消息顺序和一致性，所有写操作必须由 leader 处理。副本只用于同步和容灾，因此不能承担写入或独立读写分离的角色。"}
{"system": "你是一名并发专家。", "input": "happens-before 原则是什么？", "output": "happens-before 描述多线程间操作的可见性顺序，包括程序次序、锁规则、volatile 写→读、线程 start/join、以及传递性。只要满足 happens-before，写操作对读操作就一定可见。"}
{"system": "你是一名 Java 面试官。", "input": "什么是元空间？", "output": "元空间是 JVM 存放类元数据的区域，使用本地内存替代永久代，解决永久代容量固定易 OOM 的问题。"}
{"system": "你是一名 Java 面试官。", "input": "什么是线程安全？", "output": "线程安全指多线程访问共享资源时不会出现竞态条件，结果可预期。常见手段包括加锁、原子类、volatile、线程隔离与不可变对象。"}
{"system": "你是一名 Java 面试官。", "input": "application.properties 与 application.yml 有什么区别？", "output": "两者都是 Spring Boot 的配置文件。properties 使用 key=value，格式简单；yml 支持层级结构，更简洁可读。底层都会被解析成同一种属性源。"}
{"system": "你是一名 Java 面试官。", "input": "MySQL 的锁有哪些类型？", "output": "MySQL 锁包括：共享锁（S）、排他锁（X）、意向锁（IS/IX）、记录锁、间隙锁、临键锁（Next-Key Lock）。InnoDB 通过多种锁实现并发控制和避免幻读。"}
{"system": "你是一名专业 Java 面试官。", "input": "JVM 的主要组成部分有哪些？", "output": "JVM 包括：类加载器（ClassLoader）、运行时数据区（堆、栈、方法区等）、执行引擎（解释器+JIT）、本地方法接口（JNI）、垃圾回收系统。这些组件共同实现 Java 的跨平台运行。"}
{"system": "你是一名 Java 面试官。", "input": "RDB 和 AOF 的区别？", "output": "RDB 是快照方式，恢复速度快但可能丢几秒数据。AOF 是追加日志方式，更安全但文件更大、恢复慢。生产一般 RDB+AOF 混用，兼顾性能和可靠性。"}
{"system": "你是一名 OS 专家。", "input": "什么是竞态条件？", "output": "竞态条件是多个线程同时读写共享资源导致结果依赖执行顺序而不可预测。需要通过锁、原子操作或线程隔离来避免。"}
{"system": "你是一名并发专家。", "input": "线程池 OOM 的原因是什么？", "output": "线程池若使用无界队列会导致任务无限堆积；线程数配置过大也会消耗过多内存；任务执行耗时长则导致积压风险。需合理设置队列大小、线程数与拒绝策略。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是直接内存？", "output": "直接内存是 JVM 外的内存区域，由 NIO 的 ByteBuffer.allocateDirect 或 Unsafe 分配。它避免堆内与内核缓冲区之间的复制，适用于高性能 IO，但受 MaxDirectMemory 限制且需手动释放（Cleaner 机制）。"}
{"system": "你是一名 Java 面试官。", "input": "MyBatis 如何处理返回结果映射？", "output": "MyBatis 通过 ResultMap、自定义字段映射、自动映射（根据属性名匹配字段）、驼峰命名转换等方式，将 SQL 结果转换成 Java 对象。"}
{"system": "你是一名并发面试官。", "input": "Java 提供哪些同步机制？", "output": "Java 提供 synchronized、ReentrantLock、volatile、原子类、Semaphore、CountDownLatch、CyclicBarrier、并发容器等，用于不同场景的线程同步与协调。"}
{"system": "你是一名 Java 面试官。", "input": "ThreadLocal 内存泄漏如何避免？", "output": "在线程池中使用 ThreadLocal 时要在 finally 中手动 remove()，避免线程复用导致旧值残留。还要避免使用强引用的 ThreadLocalKey，尽量让 key 被 GC 回收。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是 Major GC（Old GC）？", "output": "Major GC 是对老年代的垃圾回收，耗时通常长于 Minor GC，并且伴随较明显的 Stop-The-World。触发条件包括老年代空间不足或 Full GC。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 ASM？", "output": "ASM 是 Java 的字节码操作框架，可直接编辑、生成和增强字节码。常用于 AOP、动态代理、框架增强（如 Spring、MyBatis）等底层技术中。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 的 Key 过期策略有哪些？", "output": "Redis 有三种过期策略：定时删除、惰性删除和定期删除（默认）。定时最准确但最耗资源；惰性删除最省资源但可能积累垃圾；定期删除是二者折中，按频率随机抽检。"}
{"system": "你是一名网络专家。", "input": "Netty 的 pipeline 是什么？", "output": "pipeline 是 Netty 的责任链结构，包含一组 inbound/outbound 处理器。用于按顺序处理解码、编码、业务逻辑，便于扩展与复用。"}
{"system": "你是一名并发专家。", "input": "自旋锁适用场景是什么？", "output": "自旋锁适用于锁持有时间非常短的情况，通过忙等避免线程挂起/恢复的开销。如果锁时间长，会浪费 CPU，不适合使用。"}
{"system": "你是一名网络专家。", "input": "什么是 CDN？", "output": "CDN 通过在各地部署边缘节点缓存静态资源，让用户就近访问，降低源站压力、减少延迟。还提供负载均衡、链路优化和容灾能力，提升整体可用性与访问速度。"}
{"system": "你是一名 Java 面试官。", "input": "MyBatis 的一级缓存是什么？", "output": "一级缓存基于 SqlSession，默认开启。相同 SqlSession 内相同 SQL 和参数会直接命中缓存，减少数据库查询。"}
{"system": "你是一名专家。", "input": "什么是多级反馈队列？", "output": "多级反馈队列通过多个优先级队列，让新任务优先运行、长任务逐渐降低优先级，兼顾响应速度与吞吐量，是操作系统常用调度算法之一。"}
{"system": "你是一名专业系统架构师。", "input": "如何设计高可用数据库？", "output": "可通过主从复制、读写分离、多主架构、分库分表、中间件路由、自动故障切换（MHA/ProxySQL）、数据校验与定期备份实现高可用。核心目标是消除单点与提高可恢复性。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是 CAS？", "output": "CAS 是 Compare-And-Swap，通过比较内存中的旧值与预期值一致时更新为新值。依赖 CPU 指令和 Unsafe，支持无锁并发，但存在 ABA 问题和自旋开销。"}
{"system": "你是一名并发专家。", "input": "线程池的核心线程与最大线程有什么区别？", "output": "核心线程默认常驻处理基本负载；当队列满时才会创建最大线程用于应对高峰流量。超过最大线程数与队列容量后会触发拒绝策略。"}
{"system": "你是一名 Java 面试官。", "input": "线程池的核心参数有哪些？", "output": "包括 corePoolSize、maximumPoolSize、keepAliveTime、workQueue、threadFactory、拒绝策略（RejectedExecutionHandler）。这些参数决定线程池的扩容策略、任务排队方式以及拒绝时的处理行为。"}
{"system": "你是一名 Java 面试官。", "input": "Java 中 clone() 的作用是什么？", "output": "clone 用于复制对象，Object 默认是浅拷贝。类必须实现 Cloneable，否则会抛 CloneNotSupportedException；深拷贝需要手动实现或通过序列化完成。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是 GC Roots？", "output": "GC Roots 是垃圾回收的起始点，用于做可达性分析。包括栈帧中的引用、静态变量、常量池引用、本地方法引用等。只有从 GC Roots 不可达的对象才会被回收。"}
{"system": "你是一名专业架构师。", "input": "系统如何监控？", "output": "通常包含指标监控（Prometheus/Grafana）、日志监控（ELK/EFK）、链路追踪（SkyWalking/Zipkin）以及告警系统。监控体系要覆盖服务状态、性能瓶颈和异常行为。"}
{"system": "你是一名 Java 面试官。", "input": "什么是类加载过程？", "output": "类加载过程包括：加载（读入字节码）、验证（格式校验）、准备（分配静态变量）、解析（符号引用转直接引用）、初始化（执行静态代码块）。整个流程用于将 Class 正式创建到 JVM 内存中。"}
{"system": "你是一名架构师。", "input": "如何设计配置中心？", "output": "配置中心需要集中管理配置、支持动态推送、版本回滚、多环境隔离以及权限控制。数据通常存储在数据库或 KV 存储，并通过长轮询或推送机制实时刷新。行业常用方案包括 Nacos、Apollo、Spring Cloud Config。"}
{"system": "你是一名专业 Java 面试官。", "input": "Java 的访问修饰符有哪些？", "output": "访问修饰符包括：public（全局可见）、protected（同包+子类可见）、default（仅同包可见）、private（仅类内可见）。用于控制封装和可访问性。"}
{"system": "你是一名专业网络面试官。", "input": "TCP 为什么是可靠的？", "output": "TCP 通过三次握手建立连接、序列号保证有序、ACK 确认机制、超时与快速重传、滑动窗口、流量控制和拥塞控制来确保可靠、有序、不丢不重的传输。"}
{"system": "你是一名架构师。", "input": "消息队列的典型问题有哪些？", "output": "典型问题包括：重复消费、消息丢失、顺序消费、消息积压、延迟消息、事务消息一致性。需要结合幂等设计、持久化、副本机制与分区策略来解决。"}
{"system": "你是一名 Java 面试官。", "input": "Nacos 的心跳机制是什么？", "output": "Nacos 临时实例通过客户端定期发送心跳，Server 根据心跳超时判断实例是否存活。非临时实例则依赖 Raft 协议维护状态。"}
{"system": "你是一名 Java 面试官。", "input": "什么是回表？", "output": "查询使用二级索引后还需根据主键到聚簇索引取整行数据，这个过程叫回表。使用覆盖索引可以避免回表，提高查询性能。"}
{"system": "你是一名并发面试官。", "input": "ForkJoinPool 是什么？", "output": "ForkJoinPool 是支持分治任务的线程池，通过 Fork 将大任务拆分、小任务并行执行，再通过 Join 合并结果。它使用 Work-Stealing 算法提升 CPU 利用率。"}
{"system": "你是一名 Java 面试官。", "input": "为什么 Integer 127 == Integer 127 为 true？", "output": "因为 Integer 会缓存 -128 到 127 的对象，值在缓存范围内时返回同一个实例。超出范围则创建新对象，== 比较时为 false。"}
{"system": "你是一名 Java 面试官。", "input": "Java 中的 main 方法签名能修改吗？", "output": "不能。main 必须是 public static void main(String[] args)，签名固定，否则 JVM 无法定位程序入口，无法启动。"}
{"system": "你是一名 JUC 专家。", "input": "什么是 Condition？", "output": "Condition 是 Lock 的等待/通知机制，相当于可控版的 wait/notify。它允许为一个锁创建多个等待队列，提高并发控制的灵活性。常用于生产者-消费者等复杂同步场景。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 如何做限流？", "output": "常用方式包括使用 Lua 脚本结合 SortedSet 实现滑动窗口限流，或通过令牌桶/漏桶算法控制请求速率。Lua 提供原子性，适合高并发下的限流逻辑。"}
{"system": "你是一名网络面试官。", "input": "WebSocket 与 HTTP 的关系？", "output": "WebSocket 通过 HTTP 发起握手（Upgrade: websocket），握手完成后升级为全双工长连接。之后通信不再使用 HTTP 请求/响应模型，延迟更低、实时性更强。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Cloud Sleuth 的作用是什么？", "output": "Sleuth 用于分布式链路追踪，为每个请求生成 TraceId 和 SpanId，在服务间传递。支持 Zipkin/Elasticsearch 上报，实现调用链可视化与性能分析。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 哨兵（Sentinel）模式是什么？", "output": "Sentinel 负责监控主库状态、选主、自动故障转移，并通知客户端更新连接信息。是 Redis 实现高可用的核心机制之一。"}
{"system": "你是一名 OS 专家。", "input": "什么是进程调度算法？", "output": "常见调度算法包括时间片轮转、最短作业优先（SJF）、优先级调度、多级反馈队列等。不同算法在响应时间、公平性和吞吐量之间做不同权衡。"}
{"system": "你是一名专家。", "input": "什么是读写锁？", "output": "读写锁允许多个读线程并发访问，但写操作需要独占锁。适用于读多写少场景，能显著提升并发度，典型实现是 ReentrantReadWriteLock。"}
{"system": "你是一名并发专家。", "input": "Java 如何保证线程安全？", "output": "常用手段包括 synchronized/Lock 加锁、原子类 CAS、volatile 保证可见性、线程封闭（ThreadLocal）、不可变对象、并发容器和分段锁等。"}
{"system": "你是一名 Java 面试官。", "input": "Shenandoah GC 的特点是什么？", "output": "Shenandoah GC 支持并发移动对象，依赖 Brooks 指针实现转发，GC 停顿时间非常短（低延迟）。其目标是与应用线程并发工作，最小化 STW。"}
{"system": "你是一名 Java 面试官。", "input": "什么是事务的两阶段提交（2PC）？", "output": "2PC 将提交拆为两步：prepare（预提交）和 commit（正式提交）。用于保证 redo log 与 binlog 一致性，并在崩溃恢复时保证数据可靠。"}
{"system": "你是一名专业 Java 面试官。", "input": "对象的内存布局是什么？", "output": "JVM 中对象包含三部分：对象头（Mark Word + 类指针）、实例字段，以及用于 8 字节对齐的填充。对象头主要存储锁信息、哈希值等元数据。整体结构跟虚拟机实现密切相关。"}
{"system": "你是一名 Java 面试官。", "input": "MySQL 幻读如何解决？", "output": "MySQL InnoDB 在 Repeatable Read 下通过间隙锁（Gap Lock）和临键锁（Next-Key Lock）阻止插入，避免同范围内出现新的记录，从而解决幻读问题。"}
{"system": "你是一名 Java 面试官。", "input": "熔断与降级有什么区别？", "output": "熔断是系统检测到错误率或延迟过高时，自动阻断下游调用；降级是业务主动返回兜底逻辑或默认值。熔断是技术保护机制，降级是业务策略，两者可配合使用。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka 的 ACK 策略有哪些？", "output": "Kafka 有三种 ACK：acks=0 不等待确认；acks=1 只等待 leader；acks=all 等待 leader 和 ISR 副本。acks=all 最安全但延迟最高。"}
{"system": "你是一名 Java 面试官。", "input": "Spring 如何实现 AOP？", "output": "Spring AOP 基于动态代理实现：接口使用 JDK Proxy，没有接口使用 CGLIB。通过切点、通知、切面将横切逻辑织入目标方法，常用于事务、日志、缓存、安全。"}
{"system": "你是一名架构师。", "input": "什么是缓存穿透？", "output": "缓存穿透指查询不存在的数据，导致请求每次都打到数据库。解决方案包括缓存空值和布隆过滤器过滤非法 Key。"}
{"system": "你是一名并发专家。", "input": "什么是 guarded suspension？", "output": "Guarded Suspension 是一种等待条件模式，线程在条件未满足时阻塞，条件满足后再继续执行。常基于 synchronized + wait/notify 或 Lock + Condition 实现。"}
{"system": "你是一名专业的网络通信面试官，请给出结构化、专业回答。", "input": "TCP 和 UDP 有什么区别？", "output": "TCP 与 UDP 的核心区别如下：\n1）连接性：TCP 面向连接（三次握手），UDP 无连接。\n2）可靠性：TCP 保证可靠传输、顺序到达；UDP 不保证可靠性与顺序。\n3）流控与拥塞控制：TCP 有滑动窗口与拥塞控制；UDP 无控制，传输更自由。\n4）性能：TCP 延迟高、开销大；UDP 延迟低、适合实时场景。\n5）典型场景：TCP 用于文件传输、HTTP；UDP 用于直播、语音、DNS 等实时业务。"}
{"system": "你是一名专家。", "input": "什么是僵尸进程？", "output": "僵尸进程是子进程退出后父进程未调用 wait() 回收状态，导致进程表条目残留。它不会占用 CPU，但会长期占用 PID，需要父进程回收或由 init 接管。"}
{"system": "你是一名并发面试官。", "input": "什么是可中断锁？", "output": "可中断锁允许线程在等待锁时响应中断并退出等待，避免长时间阻塞。ReentrantLock 提供 lockInterruptibly() 来实现这一能力。适合对响应性有要求的场景。"}
{"system": "你是一名 Java 面试官。", "input": "元空间 OOM 的原因是什么？", "output": "元空间存放类元数据，OOM 多因大量动态生成类，如 CGLIB 动态代理、字节码增强工具频繁创建类，或元空间配置过小导致内存不足。"}
{"system": "你是一名并发专家。", "input": "StampedLock 与 ReadWriteLock 区别？", "output": "StampedLock 支持乐观读，不阻塞写线程，读多写少场景性能更好。但它不可重入，也不支持条件队列，使用时必须手动校验戳记并避免死锁风险。"}
{"system": "你是一名并发面试官。", "input": "什么是偏向锁？", "output": "偏向锁通过在对象头记录线程 ID，让无竞争场景下进入同步块不需要 CAS 操作。出现竞争后会撤销偏向锁并升级为轻量级锁，适合偏向单线程的场景。"}
{"system": "你是一名 Java 面试官。", "input": "静态内部类和非静态内部类的区别？", "output": "静态内部类不依赖外部类实例，类似独立类；非静态内部类必须持有外部类实例引用。静态内部类更轻量，常用于单例模式的静态 Holder。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 Brooks 指针？", "output": "Brooks 指针是 Shenandoah GC 为每个对象增加的转发指针，用来指向对象的“当前有效位置”。GC 在后台移动对象时无需暂停应用更新引用，提高并发收集效率。"}
{"system": "你是一名 Java 面试官。", "input": "什么是标量替换？", "output": "标量替换是 JIT 优化，将逃逸分析得出的未逃逸对象拆成多个基本变量存放，避免对象分配。可提升性能并减少 GC 压力。"}
{"system": "你是一名 Java 面试官。", "input": "什么是注解？", "output": "注解是一种元数据机制，用于在类、方法、字段上附加额外语义，由编译器或运行时框架解析。常用于 Spring 组件扫描、事务管理、序列化等场景。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是 Mark Word？", "output": "Mark Word 是对象头的一部分，存储哈希码、GC 分代年龄、锁标志位、偏向线程 ID 等。是对象锁升级（偏向 → 轻量级 → 重量级）的基础元数据。"}
{"system": "你是一名专业的Java后端面试官，请针对 JVM/JMM/GC 主题给出结构化、专业回答。", "input": "什么是 JVM？", "output": "JVM 是 Java 程序的运行时环境，负责类加载、字节码执行、内存管理与 GC。它通过字节码与不同平台解耦，实现跨平台能力。核心子系统包括类加载子系统、运行时数据区、执行引擎和本地接口。"}
{"system": "你是一名专业网络面试官。", "input": "TCP 三次握手的流程是什么？", "output": "客户端先发 SYN，服务端回 SYN+ACK，最后客户端再发 ACK。三次握手确保双方收发能力都正常，并避免旧连接造成混淆。"}
{"system": "你是一名 Java 面试官。", "input": "为什么要使用 transient？", "output": "transient 用来标记字段不参与序列化，常用于避免敏感数据泄露，比如密码。也可避免序列化不可序列化的对象，如线程或文件句柄，防止序列化异常。"}
{"system": "你是一名 Java 面试官。", "input": "什么是双亲委派模型？", "output": "双亲委派模型指类加载器在加载类时先将请求委托给父类加载器，父类无法加载时子类加载器才尝试。这样避免重复加载和类冲突，保证 JDK 核心类的安全性。"}
{"system": "你是一名 Java 面试官。", "input": "什么是逃逸分析？", "output": "逃逸分析用于判断对象是否会逃出当前方法或线程作用域。结果用于优化：栈上分配、标量替换和锁消除，从而显著提升性能。"}
{"system": "你是一名 Java 面试官。", "input": "MyBatis 的核心组件有哪些？", "output": "核心组件包括 SqlSessionFactory、SqlSession、Mapper 映射器、Executor、StatementHandler、ParameterHandler 和 ResultSetHandler，分别负责会话管理、执行 SQL 与结果映射等功能。"}
{"system": "你是一名 Java 面试官。", "input": "为什么现在推荐 Spring Cloud Alibaba？", "output": "因为 Spring Cloud Alibaba 集成 Nacos、Sentinel、RocketMQ、Seata 等国产化组件，生态一致、易上手，兼容微服务全链路场景，更适合国内生产环境。"}
{"system": "你是一名 JUC 专家。", "input": "CAS 的缺点是什么？", "output": "CAS 存在 ABA 问题、自旋重试导致 CPU 开销大、只能保证单变量的原子性。解决可通过版本号（AtomicStampedReference）或限制自旋范围、用锁替代复杂场景。"}
{"system": "你是一名并发专家。", "input": "如何避免死锁？", "output": "可以通过资源有序分配（按固定顺序加锁）、使用 tryLock 设置超时、缩小锁粒度、使用并发容器或避免嵌套锁等方式降低死锁风险。本质是破坏死锁的四个必要条件之一。"}
{"system": "你是一名 Java 面试官。", "input": "JVM 优化有哪些常见方式？", "output": "常见优化包括：合理设置堆大小、选择合适 GC（G1/ZGC）、减少对象创建、利用逃逸分析做栈上分配、降低锁竞争、使用高效并发容器、减少 Full GC 次数等。"}
{"system": "你是一名专家。", "input": "如何避免僵尸进程？", "output": "父进程需调用 wait/waitpid 主动回收子进程状态，或注册 SIGCHLD 信号处理函数自动处理。确保子进程退出后不会残留在进程表中。"}
{"system": "你是一名并发专家。", "input": "Unsafe 的作用是什么？", "output": "Unsafe 提供 JVM 底层能力，比如直接内存操作、CAS、对象创建、线程休眠等。很多高性能并发类（如 Atomic 系列）都依赖它。虽然强大，但不安全，一般不建议在业务代码直接使用。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 Ribbon？有什么作用？", "output": "Ribbon 是 Netflix 出的客户端负载均衡组件，它在客户端本地维护服务列表，并基于策略（轮询、随机、权重等）选择目标实例。相比服务端负载均衡，它减少一次网络跳转，适合微服务体系中高并发、低延迟的调用场景。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Boot 如何实现跨域？", "output": "可以在 Controller 上使用 @CrossOrigin，也可以在 WebMvcConfigurer 中配置 addCorsMappings 来统一管理。后者适合全局跨域策略。"}
{"system": "你是一名操作系统面试官。", "input": "文件系统的作用是什么？", "output": "文件系统负责组织和管理磁盘数据，包括目录结构、inode 元数据、权限控制，以及对外提供文件读写接口。它让应用能以统一方式访问存储设备。"}
{"system": "你是一名操作系统专家。", "input": "什么是页表？", "output": "页表是映射虚拟地址到物理地址的数据结构，是虚拟内存实现的核心。通过页目录、页表层级查找映射，支持按页管理内存并提高隔离性和安全性。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Boot 如何实现参数校验？", "output": "使用 Hibernate Validator，通过 @Valid/@Validated 触发校验，并结合注解如 @NotNull、@Min、@Email 等。可通过 BindingResult 捕获校验错误，也可自定义校验器和错误消息。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是 happens-before 原则？", "output": "happens-before 定义了多线程间操作的可见性顺序，包括程序次序、锁释放→加锁、volatile 写→读、线程启动/终止规则以及传递性。只要满足 happens-before，线程间的读写就是可见且有序的。"}
{"system": "你是一名并发专家。", "input": "synchronized 的底层原理是什么？", "output": "synchronized 基于对象头的 Mark Word 和 Monitor 实现，锁会经历偏向锁 → 轻量级锁 → 重量级锁的升级过程，分别对应无竞争、轻竞争和强竞争场景。"}
{"system": "你是一名并发专家。", "input": "如何解决 ABA 问题？", "output": "ABA 问题可通过增加版本号或时间戳解决，例如使用 AtomicStampedReference 或 AtomicMarkableReference。它在 CAS 校验时同时比较值与版本，避免 A→B→A 的变化被误认为未改变。"}
{"system": "你是一名 Java 面试官。", "input": "Redis Pipeline 是什么？", "output": "Pipeline 可批量发送多条命令，减少 RTT 提高吞吐，但不保证原子性。适合大量写入或批处理场景，与事务、Lua 脚本可结合使用。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Boot 如何实现自动装配？", "output": "自动装配机制来自 @EnableAutoConfiguration，内部通过 AutoConfigurationImportSelector 读取 spring.factories（或 spring-autoconfigure-metadata）中的配置类，并按条件（@Conditional*）自动加载 Bean。"}
{"system": "你是一名并发专家。", "input": "AQS 支持什么模式？", "output": "AQS 支持两种同步模式：独占模式（如 ReentrantLock 独占锁）和共享模式（如 Semaphore、CountDownLatch、ReadWriteLock 读锁）。独占模式一次只允许一个线程获取，共享模式允许多个线程同时获取共享资源。"}
{"system": "你是一名 OS 面试官。", "input": "什么是用户态与内核态？", "output": "用户态权限受限，不能直接访问硬件；内核态具备完全权限，负责系统调用、设备管理等。应用通过系统调用触发中断，从用户态切换到内核态执行。"}
{"system": "你是一名网络专家。", "input": "TCP 的流量控制与拥塞控制区别？", "output": "流量控制通过 rwnd 防止接收方被压垮；拥塞控制通过 cwnd 避免网络拥塞。两者分别关注接收端与网络端的可承受能力。"}
{"system": "你是一名并发专家。", "input": "ThreadLocal 为什么会导致内存泄漏？", "output": "ThreadLocalMap key 是弱引用但 value 是强引用，若不调用 remove，key 回收后 value 仍被线程引用。线程池线程长期不销毁导致 value 无法释放，产生内存泄漏。"}
{"system": "你是一名 Java 面试官。", "input": "什么是原子类？", "output": "原子类是 JUC 提供的一组基于 CAS 的无锁并发工具，比如 AtomicInteger。它们保证单个变量操作的原子性，不需要显式加锁。在高并发场景下相比 synchronized 更轻量、更高效。"}
{"system": "你是一名并发专家。", "input": "ThreadLocal 的作用是什么？", "output": "ThreadLocal 为每个线程提供变量副本，实现线程隔离，避免共享数据竞争。常用于请求上下文、事务信息、用户会话等线程级数据存储。"}
{"system": "你是一名专业面试官。", "input": "消息重复消费如何处理？", "output": "通常通过幂等设计处理，例如使用唯一事务 ID、数据库唯一键约束、去重表、状态机记录处理流程，或使用分布式锁控制唯一执行。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 lambda 表达式？", "output": "lambda 是 Java8 引入的函数式语法，用于创建匿名函数，简化代码。本质上会生成对应的函数式接口实例（仅有一个抽象方法），常用于 Stream、回调等场景。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 Spring Cloud Config？", "output": "Spring Cloud Config 是分布式配置中心，用于统一管理配置，支持 Git/本地等存储方式，并通过 Spring Cloud Bus 实现动态刷新与版本管理。"}
{"system": "你是一名并发专家。", "input": "ReentrantLock 与 synchronized 区别？", "output": "ReentrantLock 提供可中断、可超时、可轮询、公平锁、多个 Condition 等高级特性；synchronized 更简单，由 JVM 优化，适合大多数场景。前者灵活，后者易用。"}
{"system": "你是一名 Java 面试官。", "input": "JDK 动态代理和 CGLIB 的区别？", "output": "JDK 动态代理基于接口实现，性能轻量；CGLIB 通过继承生成子类，不能代理 final 类和方法，初始成本高但运行性能更好。Spring 默认优先使用 JDK 代理。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Cloud Gateway 的作用是什么？", "output": "它是 Spring Cloud 的 API 网关，负责请求路由、过滤、鉴权、限流等能力。底层基于 Netty 和 Reactor，天然支持响应式模型。常用于微服务流量入口的统一控制。"}
{"system": "你是一名专业面试官。", "input": "什么是三地三中心？", "output": "三地三中心是企业级高可用部署架构，通常包含主中心、同城灾备中心和异地容灾中心。目的是实现跨地域的容灾切换，确保在极端故障下仍能提供业务连续性。"}
{"system": "你是一名 Java 面试官。", "input": "什么是字节码？", "output": "字节码是 Java 编译后的中间指令，由 JVM 执行。它与平台无关，使 Java 能做到跨平台运行。JVM 负责将字节码解释或 JIT 编译为机器指令。"}
{"system": "你是一名操作系统面试官。", "input": "为什么上下文切换代价大？", "output": "上下文切换需要保存/恢复寄存器、切换内核栈、刷新 TLB、导致 CPU cache 失效。以上开销会让 CPU 在调度上耗费大量时间，降低整体性能。"}
{"system": "你是一名面试官。", "input": "什么是内存泄漏？", "output": "内存泄漏是指程序持有无用对象的引用，导致 GC 无法回收，最终可能耗尽内存。在 Java 中典型场景包括静态集合没清理、ThreadLocal 未清理、连接/流未关闭等。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Cloud LoadBalancer 的作用是什么？", "output": "Spring Cloud LoadBalancer 是基于 Spring 的客户端负载均衡组件，用来替代 Ribbon。它通过策略选择服务实例，支持重试、健康检查，并与 Spring Cloud 原生态生态深度整合。"}
{"system": "你是一名专业 Java 面试官。", "input": "finalize 为什么不推荐使用？", "output": "finalize 执行时机不可控、性能差、容易导致对象复活，而且会拖慢 GC，JDK9 已被正式废弃。更推荐使用 try-with-resources 或 Cleaner/PhantomReference 管理资源释放。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 如何避免缓存雪崩？", "output": "常见方案包括：设置随机过期时间避免同时失效、多级缓存架构、提前缓存预热、对热点数据限流或降级处理，以减少瞬时数据库压力。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka 为什么吞吐高？", "output": "Kafka 高吞吐的核心原因包括顺序写磁盘、页缓存、零拷贝（sendfile）、批量发送、分区并行处理以及消息压缩协议。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 JIT？", "output": "JIT 是 JVM 的即时编译器，会把热点代码编译为本地机器码，提高执行效率。包含 C1（偏向启动速度）和 C2（偏向极致性能）。JIT 是 Java 性能可以接近原生的重要原因。"}
{"system": "你是一名 Java 面试官。", "input": "MySQL 索引的分类有哪些？", "output": "包括聚簇索引（主键）、二级索引、联合索引、唯一索引、覆盖索引、前缀索引。InnoDB 的二级索引会回表，而覆盖索引可避免回表提高查询性能。"}
{"system": "你是一名 Java 面试官。", "input": "双重检查单例为何要使用 volatile？", "output": "volatile 能禁止指令重排序，确保对象初始化完成后再发布。否则可能出现线程读取到未完全初始化的实例，导致不可预期的问题。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 Spring Boot Actuator？", "output": "Actuator 是 Spring Boot 的监控与管理模块，提供健康检查、度量指标、日志、线程信息、环境配置等端点，用于生产运维监控。"}
{"system": "你是一名 Java 面试官。", "input": "什么是包装类型缓存？", "output": "包装类型如 Integer 使用缓存池（-128~127）避免重复创建对象，提高性能。装箱时相同范围内的值会复用缓存实例。"}
{"system": "你是一名 Java 面试官。", "input": "Spring 的事务隔离级别有哪些？", "output": "隔离级别包括：DEFAULT（跟随数据库）、READ_UNCOMMITTED、READ_COMMITTED、REPEATABLE_READ、SERIALIZABLE。与数据库一致，用于控制脏读、不可重复读、幻读的发生。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 的淘汰策略有哪些？", "output": "Redis 淘汰策略包括：noeviction、volatile-lru、allkeys-lru、volatile-lfu、allkeys-lfu、volatile-random、allkeys-random、volatile-ttl，用于内存不足时选择删除哪些键。"}
{"system": "你是一名 Java 面试官。", "input": "Spring 使用 JDK Proxy 还是 CGLIB？", "output": "Spring 默认优先使用 JDK 动态代理，只要目标类实现接口；若没有接口则使用 CGLIB 通过生成子类实现代理。也可以通过配置强制使用 CGLIB，例如启用 proxyTargetClass=true。"}
{"system": "你是一名 Java 面试官。", "input": "如何解决主从延迟？", "output": "可通过提升从库硬件、增加从库数量、启用多线程复制、避免大事务、拆分热点表等方式减少同步延迟。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是安全区域（Safe Region）？", "output": "Safe Region 是线程即使暂停或阻塞仍可安全触发 GC 的区域。用于解决线程不在 Safe Point 时无法参与 GC 的问题，提升 GC 的可控性。"}
{"system": "你是一名 Java 面试官。", "input": "Java 中的锁有哪些类型？", "output": "Java 锁包括偏向锁、轻量级锁、重量级锁（synchronized），以及 ReentrantLock、ReadWriteLock、公平锁/非公平锁。不同锁适用于不同竞争场景。"}
{"system": "你是一名 OS 面试官。", "input": "什么是自旋锁？", "output": "自旋锁让线程在获取锁时通过循环等待而不挂起线程，因此无需上下文切换。适合锁持有时间非常短的场景，否则会浪费 CPU。"}
{"system": "你是一名 Java 面试官。", "input": "什么是拦截器（HandlerInterceptor）？", "output": "拦截器用于在请求处理前后插入自定义逻辑，比如鉴权、日志、监控等。生命周期包括 preHandle、postHandle 和 afterCompletion。是 Spring MVC 的链式扩展机制。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是可变参数？", "output": "可变参数语法为 type... args，本质是一个数组。必须放在形参列表最后，用于处理数量不确定的入参。适合方法调用灵活变化的场景。"}
{"system": "你是一名 Java 面试官。", "input": "什么是异常？", "output": "异常是程序运行过程中出现的非预期情况。Java 将异常分为编译时异常（必须处理）和运行时异常（可选处理），Throwable 还包括 Error（严重不可恢复）。异常机制用于提升程序健壮性与可维护性。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 Spring MVC？", "output": "Spring MVC 是基于 Servlet 的 Web 框架，核心是 DispatcherServlet 作为前端控制器。负责请求分发、参数绑定、数据转换、拦截器调用、异常处理与视图解析等。"}
{"system": "你是一名专业面试官。", "input": "强一致性、弱一致性、最终一致性的区别？", "output": "强一致性：读取总能获取到最新写入；弱一致性：不保证读取到最新值；最终一致性：系统经过一段时间后达到一致。最终一致性广泛用于分布式系统以获得高可用与高性能。"}
{"system": "你是一名 Java 面试官。", "input": "MySQL 为什么不推荐使用 UUID 作为主键？", "output": "UUID 无序且占用大，插入时会导致索引频繁分裂和碎片化，影响写性能及缓存命中率。推荐自增 ID 或雪花算法这类趋势递增的主键。"}
{"system": "你是一名 Java 面试官。", "input": "JVM 中的类加载器有哪些？", "output": "主要包括 Bootstrap（加载核心类库）、Extension/Platform、AppClassLoader。除此之外可以自定义类加载器，用来隔离模块、热部署或实现特殊加载逻辑。"}
{"system": "你是一名网络面试官。", "input": "Netty 为什么性能高？", "output": "Netty 采用多路复用的 Reactor 模型、基于 NIO 的异步非阻塞 IO、零拷贝、对象池/内存池以及高效的线程调度策略。整体减少线程切换和内存复制，提升吞吐与延迟表现。"}
{"system": "你是一名并发专家。", "input": "CompletableFuture 有什么作用？", "output": "CompletableFuture 支持异步执行、任务组合、异常处理和回调链，并可绑定自定义线程池。适合构建复杂的异步流程图，比 Future 更灵活更现代化。"}
{"system": "你是一名网络专家。", "input": "epoll 为什么高效？", "output": "epoll 采用事件驱动模型，不需要轮询整个 FD 列表；使用红黑树管理监听 FD，使用链表管理就绪队列；内核通过回调机制推送事件，降低系统调用成本。"}
{"system": "你是一名专家。", "input": "Netty 中的 EventLoop 是什么？", "output": "EventLoop 是一个长期绑定线程的事件循环，负责处理 IO 事件、普通任务和定时任务。它保证同一个 Channel 的事件都由同一线程处理，从而避免锁竞争。也因此 Netty 的并发模型非常高效。"}
{"system": "你是一名并发专家。", "input": "什么是工作队列 WorkQueue？", "output": "工作队列用于存放待执行任务，线程池会从队列中取任务执行。常见队列包括 SynchronousQueue、LinkedBlockingQueue、ArrayBlockingQueue、DelayQueue、PriorityBlockingQueue 等。"}
{"system": "你是一名 Java 面试官。", "input": "Sentinel 的限流策略有哪些？", "output": "Sentinel 的限流策略包括：Direct（快速失败）、WarmUp（预热）、RateLimiter（匀速排队）、SlowRequestRatio（基于慢调用比例）。适用于不同流控场景。"}
{"system": "你是一名架构师。", "input": "什么是熔断器的三种状态？", "output": "Closed 表示正常放行；Open 表示错误率过高后立即拒绝请求；Half-Open 则是尝试性放行少量请求验证下游是否恢复。状态会根据健康情况自动切换。"}
{"system": "你是一名并发面试官。", "input": "什么是竞态条件？", "output": "竞态条件指多个线程同时读写共享变量，使执行结果依赖执行顺序而不可预测。通常通过加锁、原子类、线程安全容器或避免共享变量来消除。"}
{"system": "你是一名并发专家。", "input": "synchronized 锁升级过程是什么?", "output": "锁会经历：无锁 → 偏向锁（无竞争快速获取）→ 轻量级锁（CAS 自旋）→ 重量级锁（阻塞队列）。升级不可逆，目的是在不同竞争场景下平衡性能。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 分布式锁如何实现？", "output": "最常用 SET key value NX PX ttl 创建锁，释放时必须比对 value 防止误删。多节点场景可用 RedLock 提升可靠性。TTL 应大于业务执行时间避免锁提前失效。"}
{"system": "你是一名 Java 面试官。", "input": "Nacos 支持哪些注册模式？", "output": "Nacos 支持临时实例和永久实例两种模式。临时实例依赖心跳检测自动摘除，永久实例通过 Raft 协议保证一致性与持久存储。"}
{"system": "你是一名架构面试官。", "input": "如何防止服务雪崩？", "output": "核心是隔离故障和快速失败，包括超时、重试、限流、熔断、线程池隔离、舱壁模型等措施。再结合缓存和异步化减轻下游压力。整体目标是把局部异常阻止在本层，不要级联放大。"}
{"system": "你是一名 Java 面试官。", "input": "Java 有哪些常用函数式接口？", "output": "常用接口包括：Supplier（供给）、Consumer（消费）、Function（输入输出转换）、Predicate（条件判断）。都位于 java.util.function 包中。"}
{"system": "你是一名 OS 专家。", "input": "为什么自旋锁不适合长时间持有？", "output": "因为自旋锁会让线程不断占用 CPU 忙等，锁持有时间长会造成严重 CPU 浪费。不如直接让线程挂起等待更高效。"}
{"system": "你是一名 Java 面试官。", "input": "Spring MVC 中常用注解有哪些？", "output": "常用注解包括 @RequestMapping、@GetMapping、@PostMapping、@RequestParam、@RequestBody、@PathVariable、@ResponseBody、@RestController。用于路由绑定、参数解析和返回值处理。"}
{"system": "你是一名 Java 面试官。", "input": "什么是函数式接口？", "output": "函数式接口只包含一个抽象方法，如 Runnable、Callable、Comparator。可作为 Lambda 表达式或方法引用的目标类型。"}
{"system": "你是一名架构师。", "input": "什么是布隆过滤器？", "output": "布隆过滤器是一种基于位数组和多哈希函数的概率判重结构，空间占用极小但存在一定误判率（不会漏判）。适用于缓存穿透、黑名单过滤等场景。"}
{"system": "你是一名 JUC 专家。", "input": "AQS 的核心机制是什么？", "output": "AQS 以 state 表示同步状态，通过 CAS 修改状态；获取失败的线程进入 CLH 双向队列并被 park 阻塞，释放锁时通过 unpark 唤醒后继线程，实现 FIFO 的同步队列调度。"}
{"system": "你是一名 Java 面试官。", "input": "重载和重写的区别？", "output": "重载是在同一类中方法名相同、参数不同，属于编译期静态分派；重写是子类复写父类方法，签名一致、返回类型可协变，用于运行时多态。"}
{"system": "你是一名网络专家。", "input": "什么是长轮询（Long Polling）？", "output": "长轮询是客户端请求后服务器阻塞等待数据，有新数据立即返回，提高实时性。相比短轮询减少无效请求，但仍占用连接资源。"}
{"system": "你是一名 Java 面试官。", "input": "Java 中的 hashCode 和 equals 如何保持一致？", "output": "如果两个对象 equals() 相等，则它们的 hashCode 必须相等，否则会导致 HashMap 等容器无法正常工作。反之 hashCode 相等不要求 equals 相等。"}
{"system": "你是一名 Java 面试官。", "input": "Java 的 switch 可用于哪些类型？", "output": "switch 可用于 int、byte、short、char、enum 和 String。对 String 的实现基于 hashCode + equals 匹配实现。"}
{"system": "你是一名并发专家。", "input": "无锁与有锁的核心区别是什么？", "output": "无锁依赖 CAS 操作实现并发，线程不会阻塞，吞吐高但逻辑复杂；有锁会阻塞线程，存在上下文切换成本，但实现更简单、语义更强。"}
{"system": "你是一名专业的Java面试官。", "input": "Redis 使用了哪些常见数据结构？", "output": "Redis 核心结构包括：String、List、Set、Hash、ZSet；以及高级结构如 HyperLogLog、Bitmap、Geo、Stream、Bitfield 等，用于实现不同场景的高效数据存储。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 主从复制原理是什么？", "output": "主从复制包括全量同步和增量同步。初次复制发送 RDB 做全量同步，之后主节点将写命令记录在 repl backlog，通过 PSYNC 机制增量同步给从节点。"}
{"system": "你是一名操作系统面试官。", "input": "为什么线程比进程轻量？", "output": "线程只需要维护自己的栈和寄存器，上下文切换成本低。进程有独立地址空间和资源，创建与切换都更重。资源越少、共享越多就越轻量。"}
{"system": "你是一名 Java 面试官。", "input": "什么是单例模式？", "output": "单例模式确保类只产生一个实例，提供全局唯一访问点。常见实现包括饿汉、懒汉、双重检查锁、静态内部类和枚举方式，其中枚举最简洁且天然防反序列化破坏。"}
{"system": "你是一名专业 Java 面试官。", "input": "程序计数器的作用是什么？", "output": "程序计数器存储当前线程下一条将执行的字节码指令地址。由于线程切换依赖时间片机制，计数器可保证线程恢复后继续从正确位置执行。"}
{"system": "你是一名专业的Java并发面试官，请给出结构化、专业回答。", "input": "什么是线程？", "output": "线程是 CPU 调度和执行的最小单位，是进程内部的独立执行流。多个线程共享同一进程的内存与资源，从而实现并发执行。线程轻量、切换成本低，可有效提升吞吐与响应性能。"}
{"system": "你是一名并发专家。", "input": "IO 密集型任务线程数建议是多少？", "output": "一般建议 CPU 核心数的 2–4 倍，或根据公式：线程数 ≈ CPU 核心数 ×（1 + 阻塞系数）。阻塞越严重，线程数越多。"}
{"system": "你是一名网络专家。", "input": "什么是零拷贝？", "output": "零拷贝是减少数据在用户态与内核态之间的多次拷贝，通过 mmap、sendfile、DMA 等技术直接在内核完成数据传输。常用于高性能网络 IO，如文件传输、Kafka、Netty。"}
{"system": "你是一名并发面试官。", "input": "线程池如何选择队列类型？", "output": "无界队列适合吞吐优先但可能导致 OOM；有界队列能限制任务数量，适合限流场景；SynchronousQueue 不存储任务，高并发下能快速移交；PriorityQueue 用于需要任务优先级的情况。"}
{"system": "你是一名架构专家。", "input": "如何设计一个支持百万在线用户的聊天系统？", "output": "关键设计包括：WebSocket 长连接、连接层与业务层分离、分布式路由（如一致性哈希）、MQ 异步解耦、离线消息存储、分区存储、服务多活、消息序列号保证顺序与幂等。"}
{"system": "你是一名 OS 专家。", "input": "上下文切换是什么？", "output": "上下文切换是 OS 保存当前任务的 CPU 寄存器、栈等状态，并切换到另一个任务继续执行的过程。切换过多会增加开销，导致 CPU 时间被消耗在调度而非执行任务上。"}
{"system": "你是一名 OS 专家。", "input": "如何预防死锁？", "output": "可通过破坏死锁四条件之一预防：资源一次性申请、允许资源抢占、按序分配资源、避免循环等待。核心是减少锁依赖与持有时间。"}
{"system": "你是一名 Java 面试官。", "input": "Redis Cluster 重新分片如何实现？", "output": "通过 reshard 或 cluster setslot 命令把某些 slot 从源节点迁移到目标节点。迁移过程采用异步复制，整个集群保持可用，不影响读写。"}
{"system": "you are a 专业面试官。", "input": "什么是一致性哈希？为什么用它？", "output": "一致性哈希将节点和数据映射到同一哈希环，节点变更时，只需迁移相邻少量数据。用于分布式缓存、负载均衡、分片存储，减少扩缩容带来的数据迁移成本。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Cloud 如何实现灰度发布？", "output": "通常通过 Gateway 自定义过滤器，根据用户标签、Header 或请求参数做条件路由，把部分流量导向灰度实例。也可以配合 Nacos、Sentinel 等实现动态规则下发。整体思路就是可控、可回滚的流量切分。"}
{"system": "你是一名 Java 面试官。", "input": "什么是类卸载？", "output": "当类加载器可被回收、类无任何实例、且 Class 对象无引用时，JVM 才能卸载该类。常用于热部署、动态加载等场景。"}
{"system": "你是一名网络通信专家。", "input": "HTTPS 是如何保证安全的？", "output": "HTTPS 通过 TLS 结合非对称加密协商对称密钥，用证书验证服务器身份。通信内容使用对称加密保护，MAC/Hash 确保完整性，从而保证机密性、认证性与防篡改。"}
{"system": "你是一名并发专家。", "input": "为什么要使用 JUC？", "output": "JUC 提供更高性能的并发工具，包括显式锁、线程池、同步器和并发集合。相比 synchronized，它在可控性、扩展性和性能上更强。适合复杂、高并发场景。"}
{"system": "你是一名 Java 面试官。", "input": "ConcurrentHashMap 的原理是什么？", "output": "JDK8 采用 CAS + synchronized 的分段锁思想，避免全表锁，提高并发度。桶内结构由链表转红黑树优化查询效率；写操作用 CAS 插入或锁定单个桶节点，保证线程安全。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 Nacos？", "output": "Nacos 是阿里开源的服务注册中心 + 配置中心，统一提供服务发现、配置管理和动态 DNS。可替代 Eureka + Config，广泛用于微服务治理。"}
{"system": "你是一名网络面试官。", "input": "什么是缓存协商？", "output": "缓存协商通过 ETag/If-None-Match 或 Last-Modified/If-Modified-Since 判断资源是否更新。若资源未变则返回 304，减少带宽与响应时间。"}
{"system": "你是一名网络专家。", "input": "什么是幂等性？", "output": "幂等性指同一操作执行多次结果一致，不会产生额外副作用。HTTP 中 GET、PUT、DELETE 是幂等的，POST 通常不是；业务中可通过 token、唯一索引、状态校验来保证幂等。"}
{"system": "你是一名并发专家。", "input": "什么是不可变对象？", "output": "不可变对象一旦创建其状态不可修改，如 String、Integer、LocalDate。它们天然线程安全，非常适合在并发环境共享，使代码更简单可靠。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Boot 中如何自定义配置？", "output": "使用 @ConfigurationProperties 将配置自动绑定到 Bean，可结合 @EnableConfigurationProperties 开启，支持类型安全、分组配置与校验。"}
{"system": "你是一名并发面试官。", "input": "Runnable 和 Callable 有什么区别？", "output": "Runnable 无返回值且不能抛出受检异常；Callable 有返回值并可抛出异常。Callable 常与 Future/ThreadPool 搭配用于异步任务。"}
{"system": "你是一名网络专家。", "input": "Netty 中的 Channel 是什么？", "output": "Channel 是 Netty 抽象的网络连接对象，封装底层 Socket，提供异步的读写操作。它与 ChannelPipeline、ChannelHandler 配合完成完整的 IO 处理链路。"}
{"system": "你是一名并发专家。", "input": "AtomicLong 与 LongAdder 区别？", "output": "AtomicLong 基于单点 CAS，竞争高时容易自旋失败导致性能抖动。LongAdder 通过分段 Cell 方式降低竞争，把写操作分散到不同变量上。高并发场景下 LongAdder 吞吐更高，但读值需汇总，可能不够实时准确。"}
{"system": "你是一名网络面试官。", "input": "HTTP 的 GET 和 POST 区别是什么？", "output": "GET 是幂等的，参数在 URL，天然可缓存、可被浏览器收藏；POST 非幂等，参数在 body，用于增加或修改资源，通常不会被缓存。语义上 GET 用于查，POST 用于写。"}
{"system": "你是一名 Java 面试官。", "input": "线程池有哪些拒绝策略？", "output": "线程池拒绝策略包括：AbortPolicy（抛异常）、DiscardPolicy（直接丢弃）、DiscardOldestPolicy（丢弃队列最旧任务）、CallerRunsPolicy（由调用线程执行）。用于处理队列满时的应对方式。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是运行时常量池？", "output": "运行时常量池是类加载后从 Class 常量池搬到方法区的结构，存储字面量、符号引用等。它支持动态常量，如 String.intern()。相比编译期常量池更灵活，可在运行时扩展。"}
{"system": "你是一名 Java 面试官。", "input": "什么是异常链？", "output": "异常链通过 initCause() 或构造方法传入 cause，用于保留底层真实异常。方便在包装业务异常时仍能追溯根因，提升排查效率。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka 中 offset 存在哪里？", "output": "Consumer offset 存储在内部 Topic：__consumer_offsets，由 Kafka 持久化管理，支持分布式消费与故障恢复。"}
{"system": "你是一名面试官。", "input": "什么是主备模式？", "output": "主备模式就是一个节点提供服务，另一个节点同步数据作为备份。当主节点故障时，系统会自动或手动切换到备节点。它重点解决高可用，但备节点平时不参与流量。"}
{"system": "你是一名架构面试官。", "input": "如何设计高可用消息队列？", "output": "关键是多副本保证可靠性（如 Kafka ISR）、合理 ACK 策略、分区提升吞吐、消费组保证可扩展性、死信队列与重试机制提升业务健壮性，并配合监控与自动故障转移。"}
{"system": "你是一名架构师。", "input": "什么是双活架构？", "output": "双活架构指两个数据中心都能同时对外提供服务，并保持数据一致性。它能提高可用性和容灾能力，但对一致性协议、数据同步、冲突解决要求很高。常见实现依赖 Paxos/Raft 或异步复制机制。"}
{"system": "你是一名并发专家。", "input": "Java 中创建线程的方式有哪些？", "output": "常见方式有：继承 Thread、实现 Runnable、实现 Callable 搭配 Future/FutureTask。实际开发推荐使用线程池统一管理，避免频繁创建销毁带来的开销。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 的 AOF 是什么？", "output": "AOF 是追加写日志文件，记录每次写操作，恢复时顺序重放。数据安全性高但文件较大，重写需要额外开销。生产一般配合 RDB 一起用。"}
{"system": "你是一名 Java 面试官。", "input": "什么是类加载器？", "output": "类加载器负责把字节码加载进 JVM 并生成 Class 对象，遵循父类委派模型。JVM 内置 Bootstrap、Ext、AppClassLoader，也支持自定义类加载器，用于热部署、隔离加载等场景。"}
{"system": "你是一名专业 Java 面试官。", "input": "volatile 为什么不能保证原子性？", "output": "volatile 只保证可见性和有序性，对“读-改-写”这种复合操作无法保证整体原子性。因此自增、自减等必须依赖 CAS 或锁来保证线程安全。"}
{"system": "你是一名 Java 面试官。", "input": "什么是覆盖索引？", "output": "覆盖索引指查询所需字段全部在索引中即可返回，无需回表访问数据页。大幅减少 IO，提高查询性能，典型如二级索引中的字段查询。"}
{"system": "you are a Java 面试官。", "input": "什么是守护线程？", "output": "守护线程用于后台任务，例如 GC。所有用户线程结束后 JVM 会自动退出，不会等待守护线程执行完毕。"}
{"system": "你是一名 Java 面试官。", "input": "什么是序列化？", "output": "序列化是将对象转成字节流用于传输或持久化，反序列化则将字节恢复为对象。Java 通过实现 Serializable 完成，transient 字段不会被序列化。"}
{"system": "你是一名操作系统面试官。", "input": "进程与线程的区别？", "output": "进程是资源分配单位，线程是 CPU 调度单位；进程间隔离强但切换开销大，线程共享内存且切换成本低。线程更适合高并发任务，而进程更稳定安全。"}
{"system": "你是一名并发专家。", "input": "线程池拒绝策略有哪些？", "output": "四种：AbortPolicy（抛异常）、CallerRunsPolicy（调用方执行）、DiscardPolicy（直接丢弃）、DiscardOldestPolicy（丢弃队列最旧任务）。用于控制队列满时的行为。"}
{"system": "你是一名专业 Java 面试官。", "input": "GC 的三种基本算法是什么？", "output": "GC 的三大基本算法包括：标记-清除（产生碎片）、复制算法（低碎片但需双倍空间）、标记-整理（无碎片但成本略高）。现代 GC 通常按代结合使用这几种算法。"}
{"system": "你是一名操作系统专家。", "input": "什么是 mmap？", "output": "mmap 将文件直接映射到进程虚拟内存空间，实现文件与内存的共享区域。访问文件像访问内存一样，高效且可实现零拷贝，适用于高性能 IO 场景。"}
{"system": "你是一名并发专家。", "input": "SynchronousQueue 是什么？", "output": "SynchronousQueue 是没有容量的队列，每次 put 都必须等待对应的 take。它更像一个直接移交的同步点，常用于线程池的直接提交策略。"}
{"system": "你是一名 Java 面试官。", "input": "什么是分层编译？", "output": "分层编译是 JVM 同时使用 C1（启动快）和 C2（高性能）编译器，根据方法热点程度动态选择编译层级，兼顾启动速度与运行性能。"}
{"system": "你是一名网络专家。", "input": "什么是 SSE（Server-Sent Events）？", "output": "SSE 是浏览器通过单个 HTTP 长连接持续接收服务端推送数据的机制，属于单向实时通信。相比 WebSocket，它更轻量、实现简单，适合日志流、消息通知、监控流等场景。"}
{"system": "你是一名专业面试官。", "input": "什么是 CAP 定理？", "output": "CAP 指一致性、可用性和分区容错性，分布式系统无法同时满足三者。由于 P 不可避免，真实系统只能在 C 与 A 之间取舍，通常选择 AP 或 CP。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是 Full GC？", "output": "Full GC 是对整个堆（新生代 + 老年代 + 方法区）进行回收，开销最大。通常由老年代不足、元空间不足、System.gc() 调用等触发，应尽量避免。"}
{"system": "你是一名网络通信专家。", "input": "什么是阻塞 IO？", "output": "阻塞 IO 在数据未就绪时会让线程挂起等待，直到内核准备好数据。简单易用但无法并发处理大量连接，不适合高性能场景。"}
{"system": "你是一名系统设计面试官。", "input": "如何设计短链接系统？", "output": "短链系统通常包括：短码生成（哈希/分布式 ID）、短链与长链的存储（数据库+缓存）、跳转服务、热点保护、访问统计以及多副本部署与容灾。核心是短码唯一、高可用与高性能跳转。"}
{"system": "你是一名专业面试官。", "input": "BASE 理论是什么？", "output": "BASE 包括基本可用、软状态和最终一致性，是对 CAP 中 AP 方向的工程化实践。它强调牺牲强一致性来换高可用和高性能。常见场景有缓存、MQ、异步处理等。"}
{"system": "你是一名 Java 面试官。", "input": "Stream 流是什么？", "output": "Stream 是对集合的函数式操作抽象，支持链式、中间操作（map/filter）与终止操作（collect/reduce）。可并行执行，提高处理大量数据的效率。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是主内存和工作内存？", "output": "主内存是所有共享变量存放的区域；每个线程都有自己的工作内存，保存从主内存拷贝的变量副本。线程的读写操作都在工作内存进行，最终需要根据 JMM 的规则同步回主内存。"}
{"system": "你是一名 Java 面试官。", "input": "Redis 如何实现消息队列？", "output": "Redis 可通过多种结构实现 MQ：List + BLPOP（简单阻塞队列）、Pub/Sub（实时但无持久化）、Stream（支持消费组、确认、持久化，最接近 MQ）、SortedSet（延时队列）。生产级推荐使用 Stream。"}
{"system": "你是一名专业 Java 面试官。", "input": "volatile 如何禁止指令重排序？", "output": "volatile 在字节码中通过插入内存屏障实现，包括 LoadLoad、LoadStore、StoreStore、StoreLoad。它保证可见性和有序性，但不保证原子性。"}
{"system": "你是一名架构面试官。", "input": "什么是舱壁模式？", "output": "舱壁模式通过将资源（线程池、连接池）按业务隔离成独立“舱室”，某个舱壁故障不会扩散，提升系统韧性。类似船舱隔水结构，常用于高可用设计。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是可达性分析？", "output": "可达性分析从 GC Roots 开始递归遍历对象图，所有不可达的对象被标记为可回收。是 JVM 垃圾回收判断对象存活的核心算法。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 ThreadLocal？", "output": "ThreadLocal 为每个线程维护独立的变量副本，避免共享数据竞争。常用于保存线程上下文，如用户信息、Session、事务信息等。"}
{"system": "你是一名 Java 面试官。", "input": "MySQL 分库分表如何设计？", "output": "分库分表常用水平拆分、垂直拆分，并通过雪花算法生成全局 ID。路由可交给中间件如 ShardingSphere、Mycat 处理，同时需解决跨库查询与事务问题。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka 的 Zero Copy 是什么？", "output": "Kafka 利用 sendfile 实现 Zero Copy，让数据直接从文件缓存传到网卡缓冲区，不经过用户态拷贝。减少 CPU 消耗，大幅提升吞吐。"}
{"system": "你是一名 Java 面试官。", "input": "什么是聚簇索引？", "output": "聚簇索引的叶子节点存储完整的行记录，因此一个表只能有一个。在 InnoDB 中主键索引就是聚簇索引，其余索引用的是主键作为指针。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Cloud 中的服务发现流程是什么？", "output": "服务启动后向注册中心注册实例；客户端从注册中心拉取服务列表并本地缓存；利用心跳维持健康状态；调用时通过负载均衡组件选择具体实例。"}
{"system": "你是一名 Java 面试官。", "input": "InnoDB 的行锁是如何实现的？", "output": "InnoDB 行锁通过记录锁（Record Lock）、间隙锁（Gap Lock）和 Next-Key Lock（记录+间隙）组合实现。用于保证可重复读并避免幻读。"}
{"system": "你是一名架构面试官。", "input": "雪花算法（Snowflake）的组成是什么？", "output": "雪花 ID 由 1 位符号位、41 位时间戳、10 位机器标识和 12 位序列号组成。保证高并发下全局唯一且趋势递增，适合分布式系统。"}
{"system": "你是一名专业 Java 面试官。", "input": "方法区存储什么？", "output": "方法区存储类的元数据（字段、方法、常量池）、运行时常量池、静态变量、JIT 编译后的代码等。JDK8 后由 Metaspace 替代 PermGen。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka 如何保证消息顺序？", "output": "Kafka 通过 Partition 保证顺序，同一 Partition 内消息按写入顺序读取。需要顺序时使用同一个 key 让消息落到同一分区即可。"}
{"system": "你是一名 Java 面试官。", "input": "什么是静态绑定与动态绑定？", "output": "静态绑定在编译期确定，比如方法重载。动态绑定在运行时根据实际对象类型选择方法，比如方法重写，是多态的核心。"}
{"system": "你是一名并发专家。", "input": "ConcurrentHashMap 如何实现线程安全？", "output": "JDK8 使用 CAS + synchronized + 红黑树组合保证并发安全。插入时桶为空采用 CAS，冲突链表用 synchronized 保护，链表过长会转红黑树提升查询性能。"}
{"system": "你是一名 Java 面试官。", "input": "Java 中的错误 Error 和异常 Exception 区别？", "output": "Error 表示 JVM 无法恢复的严重错误，比如 OOM、StackOverflow，一般不捕获；Exception 则是程序级可恢复问题，比如空指针、IO 异常。开发中主要通过 try-catch 或上抛处理 Exception。"}
{"system": "你是一名架构面试官。", "input": "为什么“先更新数据库再删缓存”会出现不一致？", "output": "因为在高并发情况下，可能出现更新数据库后，缓存还未删除时读请求读到旧数据；甚至删除缓存后又被其他线程写入旧值导致脏数据。通常使用延迟双删或订阅 binlog 修正。"}
{"system": "你是一名 Java 面试官。", "input": "什么是并行流？", "output": "并行流基于 ForkJoinPool，把数据分片后在多个线程上并行处理。适合 CPU 密集、数据量大的场景，但小数据或 IO 密集反而变慢。"}
{"system": "你是一名系统设计面试官。", "input": "如何设计一个全球唯一 ID 服务？", "output": "可使用雪花算法、号段模式（DB/Redis 分段加载）、Zookeeper 或 Etcd 分布式协调、甚至多主自增 ID。需重点解决高可用、时钟回拨、分布式冲突与性能瓶颈。"}
{"system": "你是一名 Java 面试官。", "input": "什么是泛型？", "output": "泛型使类型参数化，增强类型安全和代码复用。Java 属于擦除式泛型，编译期检查、运行时类型被擦除为 Object 或上界类型。"}
{"system": "你是一名 Java 面试官。", "input": "Thread 和 Runnable 的区别？", "output": "Thread 是类，Runnable 是接口。Runnable 更灵活，支持资源共享，也避免 Java 单继承限制，因此更推荐使用。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 JavaDoc？", "output": "JavaDoc 是 Java 的文档生成工具，可将源代码中的注释自动生成 HTML 格式的 API 文档。常用于标准化输出项目接口文档。"}
{"system": "你是一名专业 Java 面试官。", "input": "String 常量池是什么？", "output": "String 常量池存放编译期确定的字符串字面量，避免重复对象，提高内存利用率。String.intern() 可将运行期字符串加入常量池复用。"}
{"system": "你是一名 Java 面试官。", "input": "MySQL 为什么会死锁？", "output": "典型原因包括事务加锁顺序不一致、范围锁/间隙锁冲突、长事务占锁、索引不命中导致升级为行锁或表锁。死锁本质是循环等待，需要优化 SQL 与索引来避免。"}
{"system": "你是一名 Java 面试官。", "input": "Zipkin 的作用是什么？", "output": "Zipkin 是分布式链路追踪系统，用于收集 Trace/Span 数据，展示调用链，分析延迟瓶颈和故障节点。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Boot 如何实现热部署？", "output": "可以启用 Spring Boot DevTools 自动重启，也可以借助 JRebel 做更快的类热替换。DevTools 更简单，JRebel 更高效。"}
{"system": "你是一名专业面试官。", "input": "为什么 String 是不可变的？", "output": "原因包括：常量池共享需要不可变；避免被修改提高安全性（类加载、URL 等场景）；hashCode 缓存提高性能；不可变对象天然线程安全。整体提升了稳定性和性能。"}
{"system": "你是一名专业面试官。", "input": "线程和进程有什么区别？", "output": "进程是资源分配和调度的基本单位，拥有独立地址空间，切换成本高；线程共享进程内存，是 CPU 调度的基本单位，切换更轻量。多线程适合 I/O 密集和高并发场景。"}
{"system": "你是一名 Java 面试官。", "input": "什么是逃逸级别？", "output": "逃逸分析分三类：方法逃逸（仅在方法内使用）、线程逃逸（被其他线程引用）、全局逃逸（共享）。逃逸决定能否进行栈上分配、锁消除和标量替换等优化。"}
{"system": "你是一名 Java 面试官。", "input": "MyBatis 的缓存失效场景有哪些？", "output": "一级缓存会在执行增删改、事务提交、手动清理缓存、使用不同 SqlSession、动态 SQL 参与查询等场景下失效。二级缓存还会因为 Mapper 配置或跨命名空间导致失效。"}
{"system": "你是一名操作系统面试官。", "input": "临界区是什么？", "output": "临界区是访问共享资源的代码片段，如果多个线程同时执行会产生竞态。必须通过锁、信号量等同步机制保护，确保同一时间只有一个线程进入。"}
{"system": "你是一名专业面试官。", "input": "如何设计搜索引擎？", "output": "典型流程包括文本分词、建立倒排索引、相关性评分/排序模型、缓存（热点词）、多机分片与副本、索引增量更新策略。常见实现如 Elasticsearch、Solr。"}
{"system": "你是一名并发专家。", "input": "ThreadLocalMap 的 key 为什么是弱引用？", "output": "因为 ThreadLocal 实例通常存储在静态变量或线程池中，若 key 是强引用，会导致 ThreadLocal 无法被 GC 回收。使用弱引用可在 ThreadLocal 被回收后自动清理 entry，减少内存泄漏风险。"}
{"system": "你是一名 Java 面试官。", "input": "如何优化元空间？", "output": "可通过减少 CGLIB 动态代理、减少类加载数量、避免频繁生成新类来优化。也可手动调大 MetaspaceSize 和 MaxMetaspaceSize，避免频繁 Full GC。"}
{"system": "你是一名 Java 面试官。", "input": "BeanFactory 和 ApplicationContext 的区别？", "output": "BeanFactory 只提供基本 IoC 能力，Bean 延迟加载；ApplicationContext 启动时预加载单例 Bean，支持事件机制、AOP、国际化、自动装配等企业级功能，是更常用的容器。"}
{"system": "你是一名 Java 面试官。", "input": "Spring Cloud 与 Dubbo 的区别是什么？", "output": "Spring Cloud 基于 REST 与 HTTP，生态完整，适合全链路微服务治理。Dubbo 基于 RPC，高性能、低延迟，更适合强依赖的内部服务调用。两者在通信协议和体系定位上有明显差异。"}
{"system": "你是一名 Java 面试官。", "input": "MySQL 为什么会主从延迟？", "output": "主从延迟通常来自从库 IO 读取慢、SQL 执行能力弱、复制单线程瓶颈、网络延迟等。特别是从库执行复杂查询或写压力大时更易出现延迟。"}
{"system": "你是一名并发面试官。", "input": "Exchanger 是做什么的？", "output": "Exchanger 是线程之间的数据交换器，允许两个线程在同步点交换对象。适用于生产者-消费者配对或遗传算法等双线程协作任务。"}
{"system": "你是一名并发专家。", "input": "ThreadPoolExecutor 构造参数有哪些？", "output": "包括 corePoolSize、maximumPoolSize、keepAliveTime、TimeUnit、workQueue、threadFactory、RejectedExecutionHandler。它们共同决定线程池的扩容策略、任务排队方式和拒绝策略行为。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka 如何保证消息不丢失？", "output": "通过 acks=all、ISR 副本同步、写入磁盘保证持久化；生产端可开启幂等性，消费端使用事务或手动提交 offset。整体依赖多副本 + 持久化策略。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是 IoC（控制反转）？", "output": "IoC 意味着对象的创建和依赖注入交给容器，不再由业务代码主动 new。常见方式包括构造器注入、Setter 注入和依赖查找。核心价值是降低耦合、提升可测试性和可维护性。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka 的基本架构是什么？", "output": "Kafka 架构由 Producer、Consumer、Broker、Topic、Partition、Replica、副本同步机制、Offset、Consumer Group 组成。通过分区提高吞吐，通过副本保证高可用。"}
{"system": "你是一名 Java 面试官。", "input": "Java 为什么跨平台？", "output": "Java 编译生成平台无关的字节码，由不同平台的 JVM 执行。从而实现“Write once, run anywhere”，JVM 屏蔽了底层系统差异。"}
{"system": "你是一名专业 Java 面试官。", "input": "CAS 的缺点是什么？", "output": "CAS 存在 ABA 问题、自旋重试可能导致 CPU 消耗高，并且一次只能保证对一个变量进行原子操作（复杂场景需使用 AtomicReference 或锁）。"}
{"system": "你是一名专业 Java 面试官。", "input": "直接内存为什么可能导致 OOM？", "output": "直接内存不在堆中，受 MaxDirectMemory 和系统物理内存限制。如果频繁 allocateDirect 且回收不及时（Cleaner 延迟），会导致直接内存耗尽抛出 OOM。"}
{"system": "你是一名架构专家。", "input": "Redis 分布式锁存在哪些问题？", "output": "主要问题包括：主从延迟导致锁丢失、key 过期引发误释放、不可重入、不可自动续期、业务阻塞风险。通常使用 Redisson 来提供续期、可重入与原子性保证。"}
{"system": "你是一名架构面试官。", "input": "什么是服务降级？", "output": "服务降级是在系统压力过大或依赖服务不可用时，主动返回兜底逻辑或默认结果。目的是保证核心业务可用，避免请求长时间等待或导致系统雪崩。"}
{"system": "你是一名架构师。", "input": "消息队列的典型问题有哪些？", "output": "典型问题包括：重复消费、消息丢失、顺序消费、消息积压、延迟消息、事务消息一致性。需要结合幂等设计、持久化、副本机制与分区策略来解决。"}
{"system": "你是一名专业 Java 面试官。", "input": "接口和抽象类有什么区别？", "output": "接口专注行为定义，不能保存状态（Java 8+ 可有默认方法）；抽象类可包含成员变量与部分实现。接口支持多实现，抽象类只支持单继承。抽象类更适合共享基础逻辑。"}
{"system": "你是一名 OS 专家。", "input": "什么是死锁？死锁产生的条件是什么？", "output": "死锁是多个线程/进程互相等待对方持有的资源而无法继续执行。产生条件包括：互斥、不可抢占、持有并等待、循环等待，四者同时满足才会产生死锁。"}
{"system": "你是一名网络通信面试官。", "input": "出现大量 TIME_WAIT 怎么解决？", "output": "可以开启端口复用（tcp_tw_reuse/tcp_tw_recycle，注意兼容性），调整内核 TIME_WAIT 超时，或通过负载均衡分散连接压力。根本方法是减少短连接使用。"}
{"system": "你是一名架构师。", "input": "如何实现服务无感知扩缩容？", "output": "依赖服务注册中心实时更新实例列表，负载均衡自动刷新节点信息。客户端使用连接池自适应扩展，服务节点上下线时自动探活与摘除，实现无感知的增删实例。"}
{"system": "你是一名 JUC 专家。", "input": "AtomicInteger 如何实现原子性？", "output": "AtomicInteger 基于 Unsafe 的 CAS 实现，通过比较并交换保证更新原子性。失败会自旋重试，直到成功为止，避免了加锁的开销。"}
{"system": "you are 专业 Java 面试官。", "input": "什么是 DI（依赖注入）？", "output": "DI 是 IoC 的实现方式，由容器负责注入依赖对象。常见形式包括构造器注入、Setter 注入、字段注入。推荐构造器注入以确保依赖不可变和便于测试。"}
{"system": "you are a Java 面试官。", "input": "什么是注释类型？", "output": "Java 注释包括单行注释 //、多行注释 /* */、文档注释 /** */。文档注释可用于生成 JavaDoc API 文档。"}
{"system": "你是一名架构师。", "input": "为什么需要链路追踪？", "output": "主要用于在分布式系统中定位问题，因为一次请求会穿过多个服务。链路追踪能显示完整调用链、耗时和异常节点，帮助排查瓶颈和优化性能。同时也能用于监控告警和容量规划。"}
{"system": "你是一名专家。", "input": "如何避免僵尸进程？", "output": "父进程需调用 wait/waitpid 主动回收子进程状态，或注册 SIGCHLD 信号处理函数自动处理。确保子进程退出后不会残留在进程表中。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka 如何保证精准一次（exactly once）？", "output": "Kafka 依赖生产者幂等性（idempotent producer）、事务写入（producer transaction）、消费端幂等处理以及 offset 与消息写入绑定。最终实现“写入 + 提交 offset”在同一事务中提交，避免重复消费或丢消息。"}
{"system": "你是一名专业 Java 面试官。", "input": "如何减少 Stop-The-World？", "output": "可以使用并行/并发 GC（G1、ZGC、Shenandoah）减少停顿；降低对象分配频率、优化大对象；合理设置堆大小与分区结构，避免频繁 Full GC。核心目标是减少 GC Roots 扫描的成本与暂停时间。"}
{"system": "你是一名 Java 面试官。", "input": "Feign 调用如何实现负载均衡？", "output": "Feign 通过整合 Ribbon（旧版）或 Spring Cloud LoadBalancer（新版），在客户端根据策略从服务列表中选择实例，再构造请求实现负载均衡。"}
{"system": "你是一名 Java 面试官。", "input": "G1 GC 的核心特点是什么？", "output": "G1 基于 Region 分区管理内存，通过并发标记和优先回收垃圾最多的 Region 减少 STW。支持可预测的停顿时间，适合大堆与低延迟应用场景。"}
{"system": "你是一名专业面试官。", "input": "缓存与数据库一致性如何保证？", "output": "常见做法是先删除缓存再更新数据库，避免脏读。对并发较高的场景可以加延迟双删或订阅 binlog 异步清理缓存。核心原则是让缓存尽快过期，并确保更新过程可重试。"}
{"system": "你是一名 Java 面试官。", "input": "MySQL redo log 与 binlog 的区别？", "output": "redo log 属于 InnoDB，引擎级，记录物理页修改用于崩溃恢复；binlog 属于数据库服务层，记录逻辑操作用于主从同步与增量恢复。redo log 是循环写，binlog 是追加写。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 MyBatis 的 Executor？", "output": "Executor 是 MyBatis 执行 SQL 的核心组件，主要包括 SimpleExecutor（每次新 Statement）、ReuseExecutor（复用 Statement）、BatchExecutor（批处理）。各自面向不同性能场景。"}
{"system": "你是一名 Java 面试官。", "input": "MySQL 的 ReadView 是什么？", "output": "ReadView 是 InnoDB MVCC 下的可见性规则，保存当前活跃事务的 ID 列表。查询时根据版本的 trx_id 判断数据是否对当前事务可见。它保证一致性读，避免加锁。"}
{"system": "你是一名网络面试官。", "input": "操作系统中的进程是什么？", "output": "进程是操作系统进行资源分配的基本单位，包含代码段、数据段、堆栈、文件描述符和独立的内存空间。每个进程至少包含一个线程。"}
{"system": "你是一名网络通信面试官。", "input": "Netty 是什么？", "output": "Netty 是基于 Java NIO 的高性能网络通信框架，封装了 Selector、线程模型、ChannelPipeline、事件驱动等机制。常用于 RPC 框架、网关、IM、游戏服务器等高并发场景。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka 如何做流量控制？", "output": "Kafka 通过 backpressure、批量处理、动态调节消费速率以及 consumer lag 监控来实现流控。客户端会根据拉取间隔、批量大小和处理能力自动平衡消费速度，避免 broker 或 consumer 被压垮。"}
{"system": "你是一名专业面试官。", "input": "Eureka 与 Nacos 的区别是什么？", "output": "Eureka 专注注册中心，遵循 CAP 的 AP；Nacos 既是注册中心又是配置中心，支持临时与非临时实例，并能在 AP/CP 模式之间切换。生态更丰富，适用场景更广。"}
{"system": "你是一名并发专家。", "input": "什么是可重入锁？", "output": "可重入锁允许同一线程重复获取同一把锁而不会发生阻塞。synchronized 和 ReentrantLock 都支持可重入，避免递归调用等场景陷入死锁。"}
{"system": "你是一名 Java 面试官。", "input": "什么是 ISR？", "output": "ISR（In-Sync Replicas）是 Kafka 中与 leader 保持同步的副本集合。只有 ISR 成员才能被选为 leader，从而保证数据一致性与可靠性。"}
{"system": "你是一名架构师。", "input": "什么是缓存雪崩？", "output": "缓存雪崩指大量缓存同时过期导致请求直接打到数据库，压力瞬间飙升。解决方法包括：加入随机过期时间、多级缓存、缓存预热、限流与熔断等。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka 为什么使用 Page Cache？", "output": "Kafka 利用 OS Page Cache 进行顺序写入与读取，减少磁盘 IO。依赖零拷贝 sendfile，进一步降低 CPU 和内核态开销，使吞吐极高。"}
{"system": "你是一名并发面试官。", "input": "CompletableFuture 和 Future 区别？", "output": "Future 只能阻塞获取结果，不支持链式组合。CompletableFuture 支持链式异步编排、回调、异常处理，并能与线程池灵活结合，实现强大的异步流程控制。"}
{"system": "你是一名 Java 面试官。", "input": "Kafka Rebalance 何时触发？", "output": "当消费者崩溃或心跳超时、消费者加入/离开 Consumer Group、订阅 topic 变化、分区数量变化时都会触发 Rebalance。"}
{"system": "你是一名专业 Java 面试官。", "input": "什么是 Java 的多态？", "output": "多态指父类引用指向子类对象，通过方法重写实现运行时动态分派。编译期看引用类型，运行期调用实际实例的方法，提高扩展性和可维护性。"}
{"system": "你是一名 Java 面试官。", "input": "Java 的静态变量存放在哪里？", "output": "静态变量存放在方法区（JDK8 的元空间）中，由类加载器管理，与实例无关。不同类加载器加载的类有独立的静态变量。"}
{"system": "你是一名系统设计专家。", "input": "如何设计 API 限流系统？", "output": "常见方案包括：Nginx/Gateway 层限流、Sidecar 模式、Redis + Lua 实现分布式限流。核心算法有令牌桶、漏桶、固定窗口、滑动窗口。需兼顾高可用、低延迟和可观测性。"}
{"system": "你是一名系统设计面试官。", "input": "如何设计一个具有高可扩展性的系统？", "output": "高可扩展系统通常包括：1）水平扩展（Stateless 服务 + 自动扩缩容）；2）微服务拆分；3）缓存层缓解热点；4）MQ 异步解耦；5）分布式存储与分片；6）负载均衡；7）可观测性体系（监控、追踪、日志）。核心是解耦、分治与弹性伸缩能力。"}
{"system": "你是一名系统设计面试官。", "input": "如何设计日志收集系统？", "output": "一般流程是：Agent 收集日志 → 通过 MQ 或文件管道缓冲 → 落地到存储系统（ELK/ClickHouse） → 实时分析处理 → 可视化展示与告警。要保证可靠性、可扩展性和检索性能。"}
{"system": "你是一名 Java 面试官。", "input": "ArrayList 扩容机制是什么？", "output": "ArrayList 默认容量 10，扩容时按旧容量的 1.5 倍增长。扩容会导致新数组分配与全部元素复制，因此在高增长场景最好提前指定容量以避免频繁扩容成本。"}
{"system": "你是一名 Java 面试官。", "input": "Spring AOP 与 AspectJ 的区别？", "output": "Spring AOP 通过 JDK/CGLIB 动态代理实现，运行时织入，功能相对有限。AspectJ 是真正的 AOP 框架，编译期或类加载期织入，功能更强但引入成本更高。"}
{"system": "你是一名网络通信专家。", "input": "TCP 拥塞控制算法有哪些？", "output": "主要有慢启动、拥塞避免、快速重传和快速恢复。慢启动用于探测网络能力，拥塞避免控制增长速度；快速重传和快速恢复在丢包时减少回退幅度，提升吞吐。"}
{"system": "你是一名Java后端面试官。", "input": "String、StringBuilder、StringBuffer 的区别是什么？", "output": "String 不可变，任何修改都会创建新对象。StringBuilder 可变但非线程安全，适合单线程。StringBuffer 也是可变的，但加了同步保证线程安全。"}
{"system": "你是一名分布式专家。", "input": "什么是负载均衡？为什么需要？", "output": "负载均衡将请求分发到多个实例，避免单点压力过大，提高系统吞吐、可用性与扩展性。可以通过客户端负载均衡、服务端负载均衡或全局代理（如 Nginx、LB）实现。"}
{"system": "你是一名专业面试官。", "input": "分布式锁的关键要求是什么？", "output": "分布式锁必须满足：互斥性、防误删（标识校验）、超时释放、可用性与故障恢复、可重入性、公平性及高性能。常见实现有 Redis、ZooKeeper、DB 实现。"}
{"system": "你是一名分布式系统专家。", "input": "令牌桶与漏桶算法的区别？", "output": "令牌桶允许积攒令牌，可支持突发流量；漏桶以固定速率出水，不允许突发且流量更平滑。令牌桶弹性更高，漏桶更平稳。"}
{"system": "你是一名 Java 面试官。", "input": "什么是循环依赖？Spring 如何解决？", "output": "循环依赖是 Bean A 依赖 B，B 又依赖 A 的情况。Spring 对构造器注入无法解决；对 Setter 注入通过三级缓存（singletonFactories → earlySingletonObjects → singletonObjects）提前暴露半成品 Bean 来完成依赖注入。"}
